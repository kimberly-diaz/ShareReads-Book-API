import { A as AbstractCrdt, r as remove, S as ServerMsgCode, m as mergeStorageUpdates, W as WebsocketCloseCodes, C as ClientMsgCode, i as isTokenValid, a as isSameNodeOrChildOf, L as LiveObject, g as getTreesDiffOperations, O as OpCode, b as LiveList, p as parseJson, c as isJsonArray, d as compact, e as isJsonObject, f as deprecateIf } from "./shared.mjs";

export { b as LiveList, h as LiveMap, L as LiveObject } from "./shared.mjs";

const BACKOFF_RETRY_DELAYS = [ 250, 500, 1e3, 2e3, 4e3, 8e3, 1e4 ], BACKOFF_RETRY_DELAYS_SLOW = [ 2e3, 3e4, 6e4, 3e5 ];

function isValidRoomEventType(value) {
 return "my-presence" === value || "others" === value || "event" === value || "error" === value || "connection" === value;
}

function makeOthers(userMap) {
 const users = Object.values(userMap).map((user => function(s, e) {
  var t = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
  if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
   var i = 0;
   for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
  }
  return t;
 }(user, [ "_hasReceivedInitialPresence" ])));
 return {
  get count() {
   return users.length;
  },
  [Symbol.iterator]: () => users[Symbol.iterator](),
  map: callback => users.map(callback),
  toArray: () => users
 };
}

function makeStateMachine(state, context, mockedEffects) {
 const effects = mockedEffects || {
  authenticate(auth, createWebSocket) {
   const token = state.token;
   if (!token || !isTokenValid(token)) return auth(context.roomId).then((({token: token}) => {
    if ("authenticating" !== state.connection.state) return;
    authenticationSuccess(parseToken(token), createWebSocket(token)), state.token = token;
   })).catch((er => function(error) {
    "production" !== process.env.NODE_ENV && console.error("Call to authentication endpoint failed", error);
    state.token = null, updateConnection({
     state: "unavailable"
    }), state.numberOfRetry++, state.timeoutHandles.reconnect = effects.scheduleReconnect(getRetryDelay());
   }(er)));
   authenticationSuccess(parseToken(token), createWebSocket(token));
  },
  send(messageOrMessages) {
   if (null == state.socket) throw new Error("Can't send message if socket is null");
   state.socket.send(JSON.stringify(messageOrMessages));
  },
  delayFlush: delay => setTimeout(tryFlushing, delay),
  startHeartbeatInterval: () => setInterval(heartbeat, 3e4),
  schedulePongTimeout: () => setTimeout(pongTimeout, 2e3),
  scheduleReconnect: delay => setTimeout(connect, delay)
 };
 function genericSubscribe(callback) {
  return state.listeners.storage.push(callback), () => remove(state.listeners.storage, callback);
 }
 function createOrUpdateRootFromMessage(message) {
  if (0 === message.items.length) throw new Error("Internal error: cannot load storage without items");
  state.root ? function(items) {
   if (!state.root) return;
   const currentItems = new Map;
   state.items.forEach(((liveCrdt, id) => {
    currentItems.set(id, liveCrdt._toSerializedCrdt());
   }));
   const ops = getTreesDiffOperations(currentItems, new Map(items));
   notify(apply(ops, !1).updates);
  }(message.items) : state.root = function(items) {
   const [root, parentToChildren] = function(items) {
    const parentToChildren = new Map;
    let root = null;
    for (const tuple of items) {
     const parentId = tuple[1].parentId;
     if (null == parentId) root = tuple; else {
      const children = parentToChildren.get(parentId);
      null != children ? children.push(tuple) : parentToChildren.set(parentId, [ tuple ]);
     }
    }
    if (null == root) throw new Error("Root can't be null");
    return [ root, parentToChildren ];
   }(items);
   return LiveObject._deserialize(root, parentToChildren, {
    getItem: getItem,
    addItem: addItem,
    deleteItem: deleteItem,
    generateId: generateId,
    generateOpId: generateOpId,
    dispatch: storageDispatch,
    roomId: context.roomId
   });
  }(message.items);
  for (const key in state.defaultStorageRoot) null == state.root.get(key) && state.root.set(key, state.defaultStorageRoot[key]);
 }
 function addItem(id, item) {
  state.items.set(id, item);
 }
 function deleteItem(id) {
  state.items.delete(id);
 }
 function getItem(id) {
  return state.items.get(id);
 }
 function addToUndoStack(historyItem) {
  state.undoStack.length >= 50 && state.undoStack.shift(), state.isHistoryPaused ? state.pausedHistory.unshift(...historyItem) : state.undoStack.push(historyItem);
 }
 function storageDispatch(ops, reverse, storageUpdates) {
  state.isBatching ? (state.batch.ops.push(...ops), storageUpdates.forEach(((value, key) => {
   state.batch.updates.storageUpdates.set(key, mergeStorageUpdates(state.batch.updates.storageUpdates.get(key), value));
  })), state.batch.reverseOps.push(...reverse)) : (addToUndoStack(reverse), state.redoStack = [], 
  dispatch(ops), notify({
   storageUpdates: storageUpdates
  }));
 }
 function notify({storageUpdates: storageUpdates = new Map, presence: presence = !1, others: otherEvents = []}) {
  if (otherEvents.length > 0) {
   state.others = makeOthers(state.users);
   for (const event of otherEvents) for (const listener of state.listeners.others) listener(state.others, event);
  }
  if (presence) for (const listener of state.listeners["my-presence"]) listener(state.me);
  if (storageUpdates.size > 0) for (const subscriber of state.listeners.storage) subscriber(Array.from(storageUpdates.values()));
 }
 function getConnectionId() {
  if ("open" === state.connection.state || "connecting" === state.connection.state) return state.connection.id;
  if (null !== state.lastConnectionId) return state.lastConnectionId;
  throw new Error("Internal. Tried to get connection id but connection was never open");
 }
 function generateId() {
  return `${getConnectionId()}:${state.clock++}`;
 }
 function generateOpId() {
  return `${getConnectionId()}:${state.opClock++}`;
 }
 function apply(item, isLocal) {
  var _a;
  const result = {
   reverse: [],
   updates: {
    storageUpdates: new Map,
    presence: !1
   }
  }, createdNodeIds = new Set;
  for (const op of item) if ("presence" === op.type) {
   const reverse = {
    type: "presence",
    data: {}
   };
   for (const key in op.data) reverse.data[key] = state.me[key];
   if (state.me = Object.assign(Object.assign({}, state.me), op.data), null == state.buffer.presence) state.buffer.presence = op.data; else for (const key in op.data) state.buffer.presence[key] = op.data[key];
   result.reverse.unshift(reverse), result.updates.presence = !0;
  } else {
   isLocal && !op.opId && (op.opId = generateOpId());
   const applyOpResult = applyOp(op, isLocal);
   if (applyOpResult.modified) {
    const parentId = null === (_a = applyOpResult.modified.node._parent) || void 0 === _a ? void 0 : _a._id;
    createdNodeIds.has(parentId) || (result.updates.storageUpdates.set(applyOpResult.modified.node._id, mergeStorageUpdates(result.updates.storageUpdates.get(applyOpResult.modified.node._id), applyOpResult.modified)), 
    result.reverse.unshift(...applyOpResult.reverse)), op.type !== OpCode.CREATE_LIST && op.type !== OpCode.CREATE_MAP && op.type !== OpCode.CREATE_OBJECT || createdNodeIds.add(applyOpResult.modified.node._id);
   }
  }
  return result;
 }
 function applyOp(op, isLocal) {
  switch (op.opId && state.offlineOperations.delete(op.opId), op.type) {
  case OpCode.DELETE_OBJECT_KEY:
  case OpCode.UPDATE_OBJECT:
  case OpCode.DELETE_CRDT:
   {
    const item = state.items.get(op.id);
    return null == item ? {
     modified: !1
    } : item._apply(op, isLocal);
   }

  case OpCode.SET_PARENT_KEY:
   {
    const item = state.items.get(op.id);
    if (null == item) return {
     modified: !1
    };
    if (item._parent instanceof LiveList) {
     const previousKey = item._parentKey;
     return previousKey === op.parentKey ? {
      modified: !1
     } : item._parent._setChildKey(op.parentKey, item, previousKey);
    }
    return {
     modified: !1
    };
   }

  case OpCode.CREATE_OBJECT:
  case OpCode.CREATE_LIST:
  case OpCode.CREATE_MAP:
  case OpCode.CREATE_REGISTER:
   {
    const parent = state.items.get(op.parentId);
    return null == parent ? {
     modified: !1
    } : parent._attachChild(op, isLocal);
   }
  }
 }
 function connect() {
  if ("closed" !== state.connection.state && "unavailable" !== state.connection.state) return null;
  const auth = function(authentication, fetchPolyfill) {
   if ("public" === authentication.type) {
    if ("undefined" == typeof window && null == fetchPolyfill) throw new Error("To use Liveblocks client in a non-dom environment with a publicApiKey, you need to provide a fetch polyfill.");
    return room => fetchAuthEndpoint(fetchPolyfill || fetch, authentication.url, {
     room: room,
     publicApiKey: authentication.publicApiKey
    });
   }
   if ("private" === authentication.type) {
    if ("undefined" == typeof window && null == fetchPolyfill) throw new Error("To use Liveblocks client in a non-dom environment with a url as auth endpoint, you need to provide a fetch polyfill.");
    return room => fetchAuthEndpoint(fetchPolyfill || fetch, authentication.url, {
     room: room
    });
   }
   if ("custom" === authentication.type) return authentication.callback;
   throw new Error("Internal error. Unexpected authentication type");
  }(context.authentication, context.fetchPolyfill), createWebSocket = function(liveblocksServer, WebSocketPolyfill) {
   if ("undefined" == typeof window && null == WebSocketPolyfill) throw new Error("To use Liveblocks client in a non-dom environment, you need to provide a WebSocket polyfill.");
   const ws = WebSocketPolyfill || WebSocket;
   return token => new ws(`${liveblocksServer}/?token=${token}`);
  }(context.liveblocksServer, context.WebSocketPolyfill);
  updateConnection({
   state: "authenticating"
  }), effects.authenticate(auth, createWebSocket);
 }
 function authenticationSuccess(token, socket) {
  socket.addEventListener("message", onMessage), socket.addEventListener("open", onOpen), 
  socket.addEventListener("close", onClose), socket.addEventListener("error", onError), 
  updateConnection({
   state: "connecting",
   id: token.actor,
   userInfo: token.info,
   userId: token.id
  }), state.idFactory = function(connectionId) {
   let count = 0;
   return () => `${connectionId}:${count++}`;
  }(token.actor), state.socket = socket;
 }
 function onUpdatePresenceMessage(message) {
  const user = state.users[message.actor];
  if (void 0 !== message.targetActor || null == user || user._hasReceivedInitialPresence) return state.users[message.actor] = null == user ? {
   connectionId: message.actor,
   presence: message.data,
   _hasReceivedInitialPresence: !0
  } : {
   id: user.id,
   info: user.info,
   connectionId: message.actor,
   presence: Object.assign(Object.assign({}, user.presence), message.data),
   _hasReceivedInitialPresence: !0
  }, {
   type: "update",
   updates: message.data,
   user: state.users[message.actor]
  };
 }
 function onUserLeftMessage(message) {
  const userLeftMessage = message, user = state.users[userLeftMessage.actor];
  return user ? (delete state.users[userLeftMessage.actor], {
   type: "leave",
   user: user
  }) : null;
 }
 function onRoomStateMessage(message) {
  const newUsers = {};
  for (const key in message.users) {
   const connectionId = Number.parseInt(key), user = message.users[key];
   newUsers[connectionId] = {
    connectionId: connectionId,
    info: user.info,
    id: user.id
   };
  }
  return state.users = newUsers, {
   type: "reset"
  };
 }
 function onEvent(message) {
  for (const listener of state.listeners.event) listener({
   connectionId: message.actor,
   event: message.event
  });
 }
 function onUserJoinedMessage(message) {
  return state.users[message.actor] = {
   connectionId: message.actor,
   info: message.info,
   id: message.id,
   _hasReceivedInitialPresence: !0
  }, state.me && (state.buffer.messages.push({
   type: ClientMsgCode.UPDATE_PRESENCE,
   data: state.me,
   targetActor: message.actor
  }), tryFlushing()), {
   type: "enter",
   user: state.users[message.actor]
  };
 }
 function parseServerMessage(data) {
  return isJsonObject(data) ? data : null;
 }
 function onMessage(event) {
  if ("pong" === event.data) return void clearTimeout(state.timeoutHandles.pongTimeout);
  const messages = function(text) {
   const data = parseJson(text);
   return void 0 === data ? null : isJsonArray(data) ? compact(data.map((item => parseServerMessage(item)))) : compact([ parseServerMessage(data) ]);
  }(event.data);
  if (null === messages || 0 === messages.length) return;
  const updates = {
   storageUpdates: new Map,
   others: []
  };
  for (const message of messages) switch (message.type) {
  case ServerMsgCode.USER_JOINED:
   updates.others.push(onUserJoinedMessage(message));
   break;

  case ServerMsgCode.UPDATE_PRESENCE:
   {
    const othersPresenceUpdate = onUpdatePresenceMessage(message);
    othersPresenceUpdate && updates.others.push(othersPresenceUpdate);
    break;
   }

  case ServerMsgCode.BROADCASTED_EVENT:
   onEvent(message);
   break;

  case ServerMsgCode.USER_LEFT:
   {
    const event = onUserLeftMessage(message);
    event && updates.others.push(event);
    break;
   }

  case ServerMsgCode.ROOM_STATE:
   updates.others.push(onRoomStateMessage(message));
   break;

  case ServerMsgCode.INITIAL_STORAGE_STATE:
   {
    const offlineOps = new Map(state.offlineOperations);
    createOrUpdateRootFromMessage(message), applyAndSendOfflineOps(offlineOps), null == _getInitialStateResolver || _getInitialStateResolver();
    break;
   }

  case ServerMsgCode.UPDATE_STORAGE:
   apply(message.ops, !1).updates.storageUpdates.forEach(((value, key) => {
    updates.storageUpdates.set(key, mergeStorageUpdates(updates.storageUpdates.get(key), value));
   }));
   break;
  }
  notify(updates);
 }
 function onClose(event) {
  if (state.socket = null, clearTimeout(state.timeoutHandles.pongTimeout), clearInterval(state.intervalHandles.heartbeat), 
  state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush), clearTimeout(state.timeoutHandles.reconnect), 
  state.users = {}, notify({
   others: [ {
    type: "reset"
   } ]
  }), event.code >= 4e3 && event.code <= 4100) {
   updateConnection({
    state: "failed"
   });
   const error = new LiveblocksError(event.reason, event.code);
   for (const listener of state.listeners.error) listener(error);
   const delay = getRetryDelay(!0);
   state.numberOfRetry++, "production" !== process.env.NODE_ENV && console.error(`Connection to Liveblocks websocket server closed. Reason: ${error.message} (code: ${error.code}). Retrying in ${delay}ms.`), 
   updateConnection({
    state: "unavailable"
   }), state.timeoutHandles.reconnect = effects.scheduleReconnect(delay);
  } else if (event.code === WebsocketCloseCodes.CLOSE_WITHOUT_RETRY) updateConnection({
   state: "closed"
  }); else {
   const delay = getRetryDelay();
   state.numberOfRetry++, "production" !== process.env.NODE_ENV && console.warn(`Connection to Liveblocks websocket server closed (code: ${event.code}). Retrying in ${delay}ms.`), 
   updateConnection({
    state: "unavailable"
   }), state.timeoutHandles.reconnect = effects.scheduleReconnect(delay);
  }
 }
 function updateConnection(connection) {
  state.connection = connection;
  for (const listener of state.listeners.connection) listener(connection.state);
 }
 function getRetryDelay(slow = !1) {
  return slow ? BACKOFF_RETRY_DELAYS_SLOW[state.numberOfRetry < BACKOFF_RETRY_DELAYS_SLOW.length ? state.numberOfRetry : BACKOFF_RETRY_DELAYS_SLOW.length - 1] : BACKOFF_RETRY_DELAYS[state.numberOfRetry < BACKOFF_RETRY_DELAYS.length ? state.numberOfRetry : BACKOFF_RETRY_DELAYS.length - 1];
 }
 function onError() {}
 function onOpen() {
  clearInterval(state.intervalHandles.heartbeat), state.intervalHandles.heartbeat = effects.startHeartbeatInterval(), 
  "connecting" === state.connection.state && (updateConnection(Object.assign(Object.assign({}, state.connection), {
   state: "open"
  })), state.numberOfRetry = 0, void 0 !== state.lastConnectionId && (state.buffer.presence = state.me, 
  tryFlushing()), state.lastConnectionId = state.connection.id, state.root && state.buffer.messages.push({
   type: ClientMsgCode.FETCH_STORAGE
  }), tryFlushing());
 }
 function heartbeat() {
  null != state.socket && (clearTimeout(state.timeoutHandles.pongTimeout), state.timeoutHandles.pongTimeout = effects.schedulePongTimeout(), 
  state.socket.readyState === state.socket.OPEN && state.socket.send("ping"));
 }
 function pongTimeout() {
  reconnect();
 }
 function reconnect() {
  state.socket && (state.socket.removeEventListener("open", onOpen), state.socket.removeEventListener("message", onMessage), 
  state.socket.removeEventListener("close", onClose), state.socket.removeEventListener("error", onError), 
  state.socket.close(), state.socket = null), updateConnection({
   state: "unavailable"
  }), clearTimeout(state.timeoutHandles.pongTimeout), state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush), 
  clearTimeout(state.timeoutHandles.reconnect), clearInterval(state.intervalHandles.heartbeat), 
  connect();
 }
 function applyAndSendOfflineOps(offlineOps) {
  if (0 === offlineOps.size) return;
  const messages = [], ops = Array.from(offlineOps.values()), result = apply(ops, !0);
  messages.push({
   type: ClientMsgCode.UPDATE_STORAGE,
   ops: ops
  }), notify(result.updates), effects.send(messages);
 }
 function tryFlushing() {
  const storageOps = state.buffer.storageOperations;
  if (storageOps.length > 0 && storageOps.forEach((op => {
   state.offlineOperations.set(op.opId, op);
  })), null == state.socket || state.socket.readyState !== state.socket.OPEN) return void (state.buffer.storageOperations = []);
  const now = Date.now();
  if (now - state.lastFlushTime > context.throttleDelay) {
   const messages = function(state) {
    const messages = [];
    state.buffer.presence && messages.push({
     type: ClientMsgCode.UPDATE_PRESENCE,
     data: state.buffer.presence
    });
    for (const event of state.buffer.messages) messages.push(event);
    state.buffer.storageOperations.length > 0 && messages.push({
     type: ClientMsgCode.UPDATE_STORAGE,
     ops: state.buffer.storageOperations
    });
    return messages;
   }(state);
   if (0 === messages.length) return;
   effects.send(messages), state.buffer = {
    messages: [],
    storageOperations: [],
    presence: null
   }, state.lastFlushTime = now;
  } else null != state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush), 
  state.timeoutHandles.flush = effects.delayFlush(context.throttleDelay - (now - state.lastFlushTime));
 }
 function getPresence() {
  return state.me;
 }
 function dispatch(ops) {
  state.buffer.storageOperations.push(...ops), tryFlushing();
 }
 let _getInitialStatePromise = null, _getInitialStateResolver = null;
 return {
  onClose: onClose,
  onMessage: onMessage,
  authenticationSuccess: authenticationSuccess,
  heartbeat: heartbeat,
  onNavigatorOnline: function() {
   "unavailable" === state.connection.state && reconnect();
  },
  simulateSocketClose: function() {
   state.socket && state.socket.close();
  },
  simulateSendCloseEvent: function(event) {
   state.socket && onClose(event);
  },
  onVisibilityChange: function(visibilityState) {
   "visible" === visibilityState && "open" === state.connection.state && heartbeat();
  },
  getUndoStack: () => state.undoStack,
  getItemsCount: () => state.items.size,
  connect: connect,
  disconnect: function() {
   state.socket && (state.socket.removeEventListener("open", onOpen), state.socket.removeEventListener("message", onMessage), 
   state.socket.removeEventListener("close", onClose), state.socket.removeEventListener("error", onError), 
   state.socket.close(), state.socket = null), updateConnection({
    state: "closed"
   }), state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush), clearTimeout(state.timeoutHandles.reconnect), 
   clearTimeout(state.timeoutHandles.pongTimeout), clearInterval(state.intervalHandles.heartbeat), 
   state.users = {}, notify({
    others: [ {
     type: "reset"
    } ]
   }), function() {
    for (const key in state.listeners) state.listeners[key] = [];
   }();
  },
  subscribe: function(firstParam, listener, options) {
   if (firstParam instanceof AbstractCrdt) return function(crdt, innerCallback, options) {
    return genericSubscribe((updates => {
     const relatedUpdates = [];
     for (const update of updates) (null == options ? void 0 : options.isDeep) && isSameNodeOrChildOf(update.node, crdt) ? relatedUpdates.push(update) : update.node._id === crdt._id && innerCallback(update.node);
     (null == options ? void 0 : options.isDeep) && relatedUpdates.length > 0 && innerCallback(relatedUpdates);
    }));
   }(firstParam, listener, options);
   if ("function" == typeof firstParam) return genericSubscribe(firstParam);
   if (!isValidRoomEventType(firstParam)) throw new Error(`"${firstParam}" is not a valid event name`);
   return state.listeners[firstParam].push(listener), () => {
    const callbacks = state.listeners[firstParam];
    remove(callbacks, listener);
   };
  },
  unsubscribe: function(event, callback) {
   if (console.warn("unsubscribe is depreacted and will be removed in a future version.\nuse the callback returned by subscribe instead.\nSee v0.13 release notes for more information.\n"), 
   !isValidRoomEventType(event)) throw new Error(`"${event}" is not a valid event name`);
   const callbacks = state.listeners[event];
   remove(callbacks, callback);
  },
  updatePresence: function(overrides, options) {
   const oldValues = {};
   null == state.buffer.presence && (state.buffer.presence = {});
   for (const key in overrides) state.buffer.presence[key] = overrides[key], oldValues[key] = state.me[key];
   state.me = Object.assign(Object.assign({}, state.me), overrides), state.isBatching ? ((null == options ? void 0 : options.addToHistory) && state.batch.reverseOps.push({
    type: "presence",
    data: oldValues
   }), state.batch.updates.presence = !0) : (tryFlushing(), (null == options ? void 0 : options.addToHistory) && addToUndoStack([ {
    type: "presence",
    data: oldValues
   } ]), notify({
    presence: !0
   }));
  },
  broadcastEvent: function(event, options = {
   shouldQueueEventIfNotReady: !1
  }) {
   null == state.socket && 0 == options.shouldQueueEventIfNotReady || (state.buffer.messages.push({
    type: ClientMsgCode.BROADCAST_EVENT,
    event: event
   }), tryFlushing());
  },
  batch: function(callback) {
   if (state.isBatching) throw new Error("batch should not be called during a batch");
   state.isBatching = !0;
   try {
    callback();
   } finally {
    state.isBatching = !1, state.batch.reverseOps.length > 0 && addToUndoStack(state.batch.reverseOps), 
    state.batch.ops.length > 0 && (state.redoStack = []), state.batch.ops.length > 0 && dispatch(state.batch.ops), 
    notify(state.batch.updates), state.batch = {
     ops: [],
     reverseOps: [],
     updates: {
      others: [],
      storageUpdates: new Map,
      presence: !1
     }
    }, tryFlushing();
   }
  },
  undo: function() {
   if (state.isBatching) throw new Error("undo is not allowed during a batch");
   const historyItem = state.undoStack.pop();
   if (null == historyItem) return;
   state.isHistoryPaused = !1;
   const result = apply(historyItem, !0);
   notify(result.updates), state.redoStack.push(result.reverse);
   for (const op of historyItem) "presence" !== op.type && state.buffer.storageOperations.push(op);
   tryFlushing();
  },
  redo: function() {
   if (state.isBatching) throw new Error("redo is not allowed during a batch");
   const historyItem = state.redoStack.pop();
   if (null == historyItem) return;
   state.isHistoryPaused = !1;
   const result = apply(historyItem, !0);
   notify(result.updates), state.undoStack.push(result.reverse);
   for (const op of historyItem) "presence" !== op.type && state.buffer.storageOperations.push(op);
   tryFlushing();
  },
  pauseHistory: function() {
   state.pausedHistory = [], state.isHistoryPaused = !0;
  },
  resumeHistory: function() {
   state.isHistoryPaused = !1, state.pausedHistory.length > 0 && addToUndoStack(state.pausedHistory), 
   state.pausedHistory = [];
  },
  getStorage: function() {
   return state.root ? new Promise((resolve => resolve({
    root: state.root
   }))) : (null == _getInitialStatePromise && (state.buffer.messages.push({
    type: ClientMsgCode.FETCH_STORAGE
   }), tryFlushing(), _getInitialStatePromise = new Promise((resolve => _getInitialStateResolver = resolve))), 
   _getInitialStatePromise.then((() => ({
    root: state.root
   }))));
  },
  selectors: {
   getConnectionState: function() {
    return state.connection.state;
   },
   getSelf: function() {
    return "open" === state.connection.state || "connecting" === state.connection.state ? {
     connectionId: state.connection.id,
     id: state.connection.userId,
     info: state.connection.userInfo,
     presence: getPresence()
    } : null;
   },
   getPresence: getPresence,
   getOthers: function() {
    return state.others;
   }
  }
 };
}

function createRoom(options, context) {
 var _a, _b;
 const initialPresence = null !== (_a = options.initialPresence) && void 0 !== _a ? _a : options.defaultPresence, initialStorage = null !== (_b = options.initialStorage) && void 0 !== _b ? _b : options.defaultStorageRoot, machine = makeStateMachine(function(initialPresence, initialStorage) {
  return {
   connection: {
    state: "closed"
   },
   token: null,
   lastConnectionId: null,
   socket: null,
   listeners: {
    event: [],
    others: [],
    "my-presence": [],
    error: [],
    connection: [],
    storage: []
   },
   numberOfRetry: 0,
   lastFlushTime: 0,
   timeoutHandles: {
    flush: null,
    reconnect: 0,
    pongTimeout: 0
   },
   buffer: {
    presence: null == initialPresence ? {} : initialPresence,
    messages: [],
    storageOperations: []
   },
   intervalHandles: {
    heartbeat: 0
   },
   me: null == initialPresence ? {} : initialPresence,
   users: {},
   others: makeOthers({}),
   defaultStorageRoot: initialStorage,
   idFactory: null,
   clock: 0,
   opClock: 0,
   items: new Map,
   root: void 0,
   undoStack: [],
   redoStack: [],
   isHistoryPaused: !1,
   pausedHistory: [],
   isBatching: !1,
   batch: {
    ops: [],
    updates: {
     storageUpdates: new Map,
     presence: !1,
     others: []
    },
    reverseOps: []
   },
   offlineOperations: new Map
  };
 }("function" == typeof initialPresence ? initialPresence(context.roomId) : initialPresence, "function" == typeof initialStorage ? initialStorage(context.roomId) : initialStorage), context), room = {
  id: context.roomId,
  getConnectionState: machine.selectors.getConnectionState,
  getSelf: machine.selectors.getSelf,
  subscribe: machine.subscribe,
  unsubscribe: machine.unsubscribe,
  getPresence: machine.selectors.getPresence,
  updatePresence: machine.updatePresence,
  getOthers: machine.selectors.getOthers,
  broadcastEvent: machine.broadcastEvent,
  getStorage: machine.getStorage,
  batch: machine.batch,
  history: {
   undo: machine.undo,
   redo: machine.redo,
   pause: machine.pauseHistory,
   resume: machine.resumeHistory
  },
  internalDevTools: {
   closeWebsocket: machine.simulateSocketClose,
   sendCloseEvent: machine.simulateSendCloseEvent
  }
 };
 return {
  connect: machine.connect,
  disconnect: machine.disconnect,
  onNavigatorOnline: machine.onNavigatorOnline,
  onVisibilityChange: machine.onVisibilityChange,
  room: room
 };
}

class LiveblocksError extends Error {
 constructor(message, code) {
  super(message), this.code = code;
 }
}

function parseToken(token) {
 const tokenParts = token.split(".");
 if (3 !== tokenParts.length) throw new Error("Authentication error. Liveblocks could not parse the response of your authentication endpoint");
 const data = parseJson(atob(tokenParts[1]));
 if (void 0 !== data && isJsonObject(data) && "number" == typeof data.actor && (void 0 === data.id || "string" == typeof data.id)) return {
  actor: data.actor,
  id: data.id,
  info: data.info
 };
 throw new Error("Authentication error. Liveblocks could not parse the response of your authentication endpoint");
}

function fetchAuthEndpoint(fetch, endpoint, body) {
 return fetch(endpoint, {
  method: "POST",
  headers: {
   "Content-Type": "application/json"
  },
  body: JSON.stringify(body)
 }).then((res => {
  if (!res.ok) throw new AuthenticationError(`Expected a status 200 but got ${res.status} when doing a POST request on "${endpoint}"`);
  return res.json().catch((er => {
   throw new AuthenticationError(`Expected a json when doing a POST request on "${endpoint}". ${er}`);
  }));
 })).then((authResponse => {
  if ("string" != typeof authResponse.token) throw new AuthenticationError(`Expected a json with a string token when doing a POST request on "${endpoint}", but got ${JSON.stringify(authResponse)}`);
  return authResponse;
 }));
}

class AuthenticationError extends Error {
 constructor(message) {
  super(message);
 }
}

function createClient(options) {
 const clientOptions = options, throttleDelay = function(options) {
  if (void 0 === options.throttle) return 100;
  if ("number" != typeof options.throttle || options.throttle < 80 || options.throttle > 1e3) throw new Error("throttle should be a number between 80 and 1000.");
  return options.throttle;
 }(options), rooms = new Map;
 return "undefined" != typeof window && window.addEventListener("online", (() => {
  for (const [, room] of rooms) room.onNavigatorOnline();
 })), "undefined" != typeof document && document.addEventListener("visibilitychange", (() => {
  for (const [, room] of rooms) room.onVisibilityChange(document.visibilityState);
 })), {
  getRoom: function(roomId) {
   const internalRoom = rooms.get(roomId);
   return internalRoom ? internalRoom.room : null;
  },
  enter: function(roomId, options = {}) {
   let internalRoom = rooms.get(roomId);
   return internalRoom || (deprecateIf(options.defaultPresence, "Argument `defaultPresence` will be removed in @liveblocks/client 0.18. Please use `initialPresence` instead. For more info, see https://bit.ly/3Niy5aP", "defaultPresence"), 
   deprecateIf(options.defaultStorageRoot, "Argument `defaultStorageRoot` will be removed in @liveblocks/client 0.18. Please use `initialStorage` instead. For more info, see https://bit.ly/3Niy5aP", "defaultStorageRoot"), 
   internalRoom = createRoom({
    initialPresence: options.initialPresence,
    initialStorage: options.initialStorage,
    defaultPresence: options.defaultPresence,
    defaultStorageRoot: options.defaultStorageRoot
   }, {
    roomId: roomId,
    throttleDelay: throttleDelay,
    WebSocketPolyfill: clientOptions.WebSocketPolyfill,
    fetchPolyfill: clientOptions.fetchPolyfill,
    liveblocksServer: clientOptions.liveblocksServer || "wss://liveblocks.net/v5",
    authentication: prepareAuthentication(clientOptions)
   }), rooms.set(roomId, internalRoom), options.DO_NOT_USE_withoutConnecting || internalRoom.connect()), 
   internalRoom.room;
  },
  leave: function(roomId) {
   const room = rooms.get(roomId);
   room && (room.disconnect(), rooms.delete(roomId));
  }
 };
}

function prepareAuthentication(clientOptions) {
 if ("string" == typeof clientOptions.publicApiKey) return {
  type: "public",
  publicApiKey: clientOptions.publicApiKey,
  url: clientOptions.publicAuthorizeEndpoint || "https://liveblocks.io/api/public/authorize"
 };
 if ("string" == typeof clientOptions.authEndpoint) return {
  type: "private",
  url: clientOptions.authEndpoint
 };
 if ("function" == typeof clientOptions.authEndpoint) return {
  type: "custom",
  callback: clientOptions.authEndpoint
 };
 throw new Error("Invalid Liveblocks client options. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient");
}

export { createClient };
