import { L as LiveObject, b as LiveList, h as LiveMap, j as LiveRegister, A as AbstractCrdt, k as findNonSerializableValue } from "./shared.mjs";

export { C as ClientMsgCode, o as CrdtType, O as OpCode, S as ServerMsgCode, W as WebsocketCloseCodes, q as comparePosition, l as deprecate, f as deprecateIf, n as errorIf, s as makePosition, t as throwUsageError } from "./shared.mjs";

function lsonObjectToJson(obj) {
 const result = {};
 for (const key in obj) {
  const val = obj[key];
  void 0 !== val && (result[key] = lsonToJson(val));
 }
 return result;
}

function lsonListToJson(value) {
 return value.map(lsonToJson);
}

function lsonToJson(value) {
 if (value instanceof LiveObject) return lsonObjectToJson(value.toObject());
 if (value instanceof LiveList) return function(value) {
  return lsonListToJson(value.toArray());
 }(value);
 if (value instanceof LiveMap) return function(map) {
  const result = {};
  for (const [key, value] of map.entries()) result[key] = lsonToJson(value);
  return result;
 }(value);
 if (value instanceof LiveRegister) return value.data;
 if (value instanceof AbstractCrdt) throw new Error("Unhandled subclass of AbstractCrdt encountered");
 return Array.isArray(value) ? lsonListToJson(value) : isPlainObject(value) ? lsonObjectToJson(value) : value;
}

function isPlainObject(obj) {
 return null !== obj && "[object Object]" === Object.prototype.toString.call(obj);
}

function anyToCrdt(obj) {
 if (null == obj) return obj;
 if (Array.isArray(obj)) return new LiveList(obj.map(anyToCrdt));
 if (isPlainObject(obj)) {
  const init = {};
  for (const key in obj) init[key] = anyToCrdt(obj[key]);
  return new LiveObject(init);
 }
 return obj;
}

function patchLiveObjectKey(liveObject, key, prev, next) {
 if ("production" !== process.env.NODE_ENV) {
  const nonSerializableValue = findNonSerializableValue(next);
  if (nonSerializableValue) return void console.error(`New state path: '${nonSerializableValue.path}' value: '${nonSerializableValue.value}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`);
 }
 const value = liveObject.get(key);
 if (void 0 === next) liveObject.delete(key); else if (void 0 === value) liveObject.set(key, anyToCrdt(next)); else {
  if (prev === next) return;
  value instanceof LiveList && Array.isArray(prev) && Array.isArray(next) ? function(liveList, prev, next) {
   let i = 0, prevEnd = prev.length - 1, nextEnd = next.length - 1, prevNode = prev[0], nextNode = next[0];
   outer: {
    for (;prevNode === nextNode; ) {
     if (++i, i > prevEnd || i > nextEnd) break outer;
     prevNode = prev[i], nextNode = next[i];
    }
    for (prevNode = prev[prevEnd], nextNode = next[nextEnd]; prevNode === nextNode; ) {
     if (prevEnd--, nextEnd--, i > prevEnd || i > nextEnd) break outer;
     prevNode = prev[prevEnd], nextNode = next[nextEnd];
    }
   }
   if (i > prevEnd) {
    if (i <= nextEnd) for (;i <= nextEnd; ) liveList.insert(anyToCrdt(next[i]), i), 
    i++;
   } else if (i > nextEnd) {
    let localI = i;
    for (;localI <= prevEnd; ) liveList.delete(i), localI++;
   } else {
    for (;i <= prevEnd && i <= nextEnd; ) {
     prevNode = prev[i], nextNode = next[i];
     const liveListNode = liveList.get(i);
     liveListNode instanceof LiveObject && isPlainObject(prevNode) && isPlainObject(nextNode) ? patchLiveObject(liveListNode, prevNode, nextNode) : liveList.set(i, anyToCrdt(nextNode)), 
     i++;
    }
    for (;i <= nextEnd; ) liveList.insert(anyToCrdt(next[i]), i), i++;
    let localI = i;
    for (;localI <= prevEnd; ) liveList.delete(i), localI++;
   }
  }(value, prev, next) : value instanceof LiveObject && isPlainObject(prev) && isPlainObject(next) ? patchLiveObject(value, prev, next) : liveObject.set(key, anyToCrdt(next));
 }
}

function patchLiveObject(root, prev, next) {
 const updates = {};
 for (const key in next) patchLiveObjectKey(root, key, prev[key], next[key]);
 for (const key in prev) void 0 === next[key] && root.delete(key);
 Object.keys(updates).length > 0 && root.update(updates);
}

function patchImmutableObject(state, updates) {
 return updates.reduce(((state, update) => function(state, update) {
  const path = function(node) {
   const path = [];
   for (;null != node._parentKey && null != node._parent; ) node._parent instanceof LiveList ? path.push(node._parent._indexOfPosition(node._parentKey)) : path.push(node._parentKey), 
   node = node._parent;
   return path;
  }(update.node);
  return patchImmutableNode(state, path, update);
 }(state, update)), state);
}

function patchImmutableNode(state, path, update) {
 var _a, _b, _c, _d;
 const pathItem = path.pop();
 if (void 0 === pathItem) switch (update.type) {
 case "LiveObject":
  {
   if ("object" != typeof state) throw new Error("Internal: received update on LiveObject but state was not an object");
   const newState = Object.assign({}, state);
   for (const key in update.updates) if ("update" === (null === (_a = update.updates[key]) || void 0 === _a ? void 0 : _a.type)) {
    const val = update.node.get(key);
    void 0 !== val && (newState[key] = lsonToJson(val));
   } else "delete" === (null === (_b = update.updates[key]) || void 0 === _b ? void 0 : _b.type) && delete newState[key];
   return newState;
  }

 case "LiveList":
  {
   if (!1 === Array.isArray(state)) throw new Error("Internal: received update on LiveList but state was not an array");
   let newState = state.map((x => x));
   for (const listUpdate of update.updates) "set" === listUpdate.type ? newState = newState.map(((item, index) => index === listUpdate.index ? listUpdate.item : item)) : "insert" === listUpdate.type ? listUpdate.index === newState.length ? newState.push(lsonToJson(listUpdate.item)) : newState = [ ...newState.slice(0, listUpdate.index), lsonToJson(listUpdate.item), ...newState.slice(listUpdate.index) ] : "delete" === listUpdate.type ? newState.splice(listUpdate.index, 1) : "move" === listUpdate.type && (newState = listUpdate.previousIndex > listUpdate.index ? [ ...newState.slice(0, listUpdate.index), lsonToJson(listUpdate.item), ...newState.slice(listUpdate.index, listUpdate.previousIndex), ...newState.slice(listUpdate.previousIndex + 1) ] : [ ...newState.slice(0, listUpdate.previousIndex), ...newState.slice(listUpdate.previousIndex + 1, listUpdate.index + 1), lsonToJson(listUpdate.item), ...newState.slice(listUpdate.index + 1) ]);
   return newState;
  }

 case "LiveMap":
  {
   if ("object" != typeof state) throw new Error("Internal: received update on LiveMap but state was not an object");
   const newState = Object.assign({}, state);
   for (const key in update.updates) "update" === (null === (_c = update.updates[key]) || void 0 === _c ? void 0 : _c.type) ? newState[key] = lsonToJson(update.node.get(key)) : "delete" === (null === (_d = update.updates[key]) || void 0 === _d ? void 0 : _d.type) && delete newState[key];
   return newState;
  }
 }
 if (Array.isArray(state)) {
  const newArray = [ ...state ];
  return newArray[pathItem] = patchImmutableNode(state[pathItem], path, update), newArray;
 }
 return Object.assign(Object.assign({}, state), {
  [pathItem]: patchImmutableNode(state[pathItem], path, update)
 });
}

export { lsonToJson, patchImmutableObject, patchLiveObjectKey };
