/**
 * Represents an indefinitely deep arbitrary JSON data structure. There are
 * four types that make up the Json family:
 *
 * - Json         any legal JSON value
 * - JsonScalar   any legal JSON leaf value (no lists or objects)
 * - JsonArray    a JSON value whose outer type is an array
 * - JsonObject   a JSON value whose outer type is an object
 *
 */
declare type Json = JsonScalar | JsonArray | JsonObject;
declare type JsonScalar = string | number | boolean | null;
declare type JsonArray = Json[];
declare type JsonObject = {
    [key: string]: Json | undefined;
};

/**
 * The LiveMap class is similar to a JavaScript Map that is synchronized on all clients.
 * Keys should be a string, and values should be serializable to JSON.
 * If multiple clients update the same property simultaneously, the last modification received by the Liveblocks servers is the winner.
 */
declare class LiveMap<TKey extends string = string, TValue extends Lson = Lson> extends AbstractCrdt {
    private _map;
    constructor(entries?: readonly (readonly [TKey, TValue])[] | undefined);
    /**
     * @deprecated Please call as `new LiveMap()` or `new LiveMap([])` instead.
     */
    constructor(entries: null);
    /**
     * Returns a specified element from the LiveMap.
     * @param key The key of the element to return.
     * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.
     */
    get(key: TKey): TValue | undefined;
    /**
     * Adds or updates an element with a specified key and a value.
     * @param key The key of the element to add. Should be a string.
     * @param value The value of the element to add. Should be serializable to JSON.
     */
    set(key: TKey, value: TValue): void;
    /**
     * Returns the number of elements in the LiveMap.
     */
    get size(): number;
    /**
     * Returns a boolean indicating whether an element with the specified key exists or not.
     * @param key The key of the element to test for presence.
     */
    has(key: TKey): boolean;
    /**
     * Removes the specified element by key.
     * @param key The key of the element to remove.
     * @returns true if an element existed and has been removed, or false if the element does not exist.
     */
    delete(key: TKey): boolean;
    /**
     * Returns a new Iterator object that contains the [key, value] pairs for each element.
     */
    entries(): IterableIterator<[TKey, TValue]>;
    /**
     * Same function object as the initial value of the entries method.
     */
    [Symbol.iterator](): IterableIterator<[TKey, TValue]>;
    /**
     * Returns a new Iterator object that contains the keys for each element.
     */
    keys(): IterableIterator<TKey>;
    /**
     * Returns a new Iterator object that contains the values for each element.
     */
    values(): IterableIterator<TValue>;
    /**
     * Executes a provided function once per each key/value pair in the Map object, in insertion order.
     * @param callback Function to execute for each entry in the map.
     */
    forEach(callback: (value: TValue, key: TKey, map: LiveMap<TKey, TValue>) => void): void;
}

/**
 * Think of Lson as a sibling of the Json data tree, except that the nested
 * data structure can contain a mix of Json values and LiveStructure instances.
 */
declare type Lson = Json | LiveObject<LsonObject> | LiveList<Lson> | LiveMap<string, Lson>;
/**
 * A mapping of keys to Lson values. A Lson value is any valid JSON
 * value or a Live storage data structure (LiveMap, LiveList, etc.)
 */
declare type LsonObject = {
    [key: string]: Lson | undefined;
};

/**
 * The LiveList class represents an ordered collection of items that is synchronized across clients.
 */
declare class LiveList<TItem extends Lson = Lson> extends AbstractCrdt {
    private _items;
    constructor(items?: TItem[]);
    /**
     * Returns the number of elements.
     */
    get length(): number;
    /**
     * Adds one element to the end of the LiveList.
     * @param element The element to add to the end of the LiveList.
     */
    push(element: TItem): void;
    /**
     * Inserts one element at a specified index.
     * @param element The element to insert.
     * @param index The index at which you want to insert the element.
     */
    insert(element: TItem, index: number): void;
    /**
     * Move one element from one index to another.
     * @param index The index of the element to move
     * @param targetIndex The index where the element should be after moving.
     */
    move(index: number, targetIndex: number): void;
    /**
     * Deletes an element at the specified index
     * @param index The index of the element to delete
     */
    delete(index: number): void;
    clear(): void;
    set(index: number, item: TItem): void;
    /**
     * Returns an Array of all the elements in the LiveList.
     */
    toArray(): TItem[];
    /**
     * Tests whether all elements pass the test implemented by the provided function.
     * @param predicate Function to test for each element, taking two arguments (the element and its index).
     * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.
     */
    every(predicate: (value: TItem, index: number) => unknown): boolean;
    /**
     * Creates an array with all elements that pass the test implemented by the provided function.
     * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.
     * @returns An array with the elements that pass the test.
     */
    filter(predicate: (value: TItem, index: number) => unknown): TItem[];
    /**
     * Returns the first element that satisfies the provided testing function.
     * @param predicate Function to execute on each value.
     * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.
     */
    find(predicate: (value: TItem, index: number) => unknown): TItem | undefined;
    /**
     * Returns the index of the first element in the LiveList that satisfies the provided testing function.
     * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.
     * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.
     */
    findIndex(predicate: (value: TItem, index: number) => unknown): number;
    /**
     * Executes a provided function once for each element.
     * @param callbackfn Function to execute on each element.
     */
    forEach(callbackfn: (value: TItem, index: number) => void): void;
    /**
     * Get the element at the specified index.
     * @param index The index on the element to get.
     * @returns The element at the specified index or undefined.
     */
    get(index: number): TItem | undefined;
    /**
     * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.
     * @param searchElement Element to locate.
     * @param fromIndex The index to start the search at.
     * @returns The first index of the element in the LiveList; -1 if not found.
     */
    indexOf(searchElement: TItem, fromIndex?: number): number;
    /**
     * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.
     * @param searchElement Element to locate.
     * @param fromIndex The index at which to start searching backwards.
     * @returns
     */
    lastIndexOf(searchElement: TItem, fromIndex?: number): number;
    /**
     * Creates an array populated with the results of calling a provided function on every element.
     * @param callback Function that is called for every element.
     * @returns An array with each element being the result of the callback function.
     */
    map<U>(callback: (value: TItem, index: number) => U): U[];
    /**
     * Tests whether at least one element in the LiveList passes the test implemented by the provided function.
     * @param predicate Function to test for each element.
     * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.
     */
    some(predicate: (value: TItem, index: number) => unknown): boolean;
    [Symbol.iterator](): IterableIterator<TItem>;
}

/**
 * This helper type is effectively a no-op, but will force TypeScript to
 * "evaluate" any named helper types in its definition. This can sometimes make
 * API signatures clearer in IDEs.
 *
 * For example, in:
 *
 *   type Payload<T> = { data: T };
 *
 *   let r1: Payload<string>;
 *   let r2: Resolve<Payload<string>>;
 *
 * The inferred type of `r1` is going to be `Payload<string>` which shows up in
 * editor hints, and it may be unclear what's inside if you don't know the
 * definition of `Payload`.
 *
 * The inferred type of `r2` is going to be `{ data: string }`, which may be
 * more helpful.
 *
 * This trick comes from:
 * https://effectivetypescript.com/2022/02/25/gentips-4-display/
 */
declare type Resolve<T> = T extends Function ? T : {
    [K in keyof T]: T[K];
};
declare type MyPresenceCallback<T extends Presence = Presence> = (me: T) => void;
declare type OthersEventCallback<T extends Presence = Presence> = (others: Others<T>, event: OthersEvent<T>) => void;
declare type EventCallback = ({ connectionId, event, }: {
    connectionId: number;
    event: Json;
}) => void;
declare type ErrorCallback = (error: Error) => void;
declare type ConnectionCallback = (state: ConnectionState) => void;
declare type UpdateDelta = {
    type: "update";
} | {
    type: "delete";
};
/**
 * A LiveMap notification that is sent in-client to any subscribers whenever
 * one or more of the values inside the LiveMap instance have changed.
 */
declare type LiveMapUpdates<TKey extends string, TValue extends Lson> = {
    type: "LiveMap";
    node: LiveMap<TKey, TValue>;
    updates: {
        [key: string]: UpdateDelta;
    };
};
declare type LiveObjectUpdateDelta<O extends {
    [key: string]: unknown;
}> = {
    [K in keyof O]?: UpdateDelta | undefined;
};
/**
 * A LiveObject notification that is sent in-client to any subscribers whenever
 * one or more of the entries inside the LiveObject instance have changed.
 */
declare type LiveObjectUpdates<TData extends LsonObject> = {
    type: "LiveObject";
    node: LiveObject<TData>;
    updates: LiveObjectUpdateDelta<TData>;
};
declare type LiveListUpdateDelta = {
    index: number;
    item: any;
    type: "insert";
} | {
    index: number;
    type: "delete";
} | {
    index: number;
    previousIndex: number;
    item: any;
    type: "move";
} | {
    index: number;
    item: any;
    type: "set";
};
/**
 * A LiveList notification that is sent in-client to any subscribers whenever
 * one or more of the items inside the LiveList instance have changed.
 */
declare type LiveListUpdates<TItem extends Lson> = {
    type: "LiveList";
    node: LiveList<TItem>;
    updates: LiveListUpdateDelta[];
};
declare type BroadcastOptions = {
    /**
     * Whether or not event is queued if the connection is currently closed.
     *
     * ❗ We are not sure if we want to support this option in the future so it might be deprecated to be replaced by something else
     */
    shouldQueueEventIfNotReady: boolean;
};
/**
 * The payload of notifications sent (in-client) when LiveStructures change.
 * Messages of this kind are not originating from the network, but are 100%
 * in-client.
 */
declare type StorageUpdate = LiveMapUpdates<string, Lson> | LiveObjectUpdates<LsonObject> | LiveListUpdates<Lson>;
declare type RoomInitializers<TPresence, TStorage> = Resolve<{
    /**
     * The initial Presence to use and announce when you enter the Room. The
     * Presence is available on all users in the Room (me & others).
     */
    initialPresence?: TPresence | ((roomId: string) => TPresence);
    /**
     * The initial Storage to use when entering a new Room.
     */
    initialStorage?: TStorage | ((roomId: string) => TStorage);
    /**
     * @deprecated Please use `initialPresence` instead. This property is
     * scheduled for removal in 0.18.
     */
    defaultPresence?: () => TPresence;
    /**
     * @deprecated Please use `initialStorage` instead. This property is
     * scheduled for removal in 0.18.
     */
    defaultStorageRoot?: TStorage;
}>;
declare type Client = {
    /**
     * Gets a room. Returns null if {@link Client.enter} has not been called previously.
     *
     * @param roomId The id of the room
     */
    getRoom(roomId: string): Room | null;
    /**
     * Enters a room and returns it.
     * @param roomId The id of the room
     * @param options Optional. You can provide initializers for the Presence or Storage when entering the Room.
     */
    enter<TStorage extends Record<string, any> = Record<string, any>>(roomId: string, options?: RoomInitializers<Presence, TStorage>): Room;
    /**
     * Leaves a room.
     * @param roomId The id of the room
     */
    leave(roomId: string): void;
};
/**
 * Represents all the other users connected in the room. Treated as immutable.
 */
interface Others<TPresence extends Presence = Presence> {
    /**
     * Number of other users in the room.
     */
    readonly count: number;
    /**
     * Returns a new Iterator object that contains the users.
     */
    [Symbol.iterator](): IterableIterator<User<TPresence>>;
    /**
     * Returns the array of connected users in room.
     */
    toArray(): User<TPresence>[];
    /**
     * This function let you map over the connected users in the room.
     */
    map<U>(callback: (user: User<TPresence>) => U): U[];
}
/**
 * Represents a user connected in a room. Treated as immutable.
 */
declare type User<TPresence extends Presence = Presence> = {
    /**
     * The connection id of the user. It is unique and increment at every new connection.
     */
    readonly connectionId: number;
    /**
     * The id of the user that has been set in the authentication endpoint.
     * Useful to get additional information about the connected user.
     */
    readonly id?: string;
    /**
     * Additional user information that has been set in the authentication endpoint.
     */
    readonly info?: any;
    /**
     * The user presence.
     */
    readonly presence?: TPresence;
};
declare type Presence = Record<string, unknown>;
declare type AuthEndpointCallback = (room: string) => Promise<{
    token: string;
}>;
declare type AuthEndpoint = string | AuthEndpointCallback;
/**
 * The authentication endpoint that is called to ensure that the current user has access to a room.
 * Can be an url or a callback if you need to add additional headers.
 */
declare type ClientOptions = {
    throttle?: number;
    fetchPolyfill?: any;
    WebSocketPolyfill?: any;
} & ({
    publicApiKey: string;
    authEndpoint?: never;
} | {
    publicApiKey?: never;
    authEndpoint: AuthEndpoint;
});
declare type Connection = {
    state: "closed" | "authenticating" | "unavailable" | "failed";
} | {
    state: "open" | "connecting";
    id: number;
    userId?: string;
    userInfo?: any;
};
declare type ConnectionState = Connection["state"];
declare type OthersEvent<T extends Presence = Presence> = {
    type: "leave";
    user: User<T>;
} | {
    type: "enter";
    user: User<T>;
} | {
    type: "update";
    user: User<T>;
    updates: Partial<T>;
} | {
    type: "reset";
};
interface History {
    /**
     * Undoes the last operation executed by the current client.
     * It does not impact operations made by other clients.
     *
     * @example
     * room.updatePresence({ selectedId: "xxx" }, { addToHistory: true });
     * room.updatePresence({ selectedId: "yyy" }, { addToHistory: true });
     * room.history.undo();
     * // room.getPresence() equals { selectedId: "xxx" }
     */
    undo: () => void;
    /**
     * Redoes the last operation executed by the current client.
     * It does not impact operations made by other clients.
     *
     * @example
     * room.updatePresence({ selectedId: "xxx" }, { addToHistory: true });
     * room.updatePresence({ selectedId: "yyy" }, { addToHistory: true });
     * room.history.undo();
     * // room.getPresence() equals { selectedId: "xxx" }
     * room.history.redo();
     * // room.getPresence() equals { selectedId: "yyy" }
     */
    redo: () => void;
    /**
     * All future modifications made on the Room will be merged together to create a single history item until resume is called.
     *
     * @example
     * room.updatePresence({ cursor: { x: 0, y: 0 } }, { addToHistory: true });
     * room.history.pause();
     * room.updatePresence({ cursor: { x: 1, y: 1 } }, { addToHistory: true });
     * room.updatePresence({ cursor: { x: 2, y: 2 } }, { addToHistory: true });
     * room.history.resume();
     * room.history.undo();
     * // room.getPresence() equals { cursor: { x: 0, y: 0 } }
     */
    pause: () => void;
    /**
     * Resumes history. Modifications made on the Room are not merged into a single history item anymore.
     *
     * @example
     * room.updatePresence({ cursor: { x: 0, y: 0 } }, { addToHistory: true });
     * room.history.pause();
     * room.updatePresence({ cursor: { x: 1, y: 1 } }, { addToHistory: true });
     * room.updatePresence({ cursor: { x: 2, y: 2 } }, { addToHistory: true });
     * room.history.resume();
     * room.history.undo();
     * // room.getPresence() equals { cursor: { x: 0, y: 0 } }
     */
    resume: () => void;
}
declare type Room = {
    /**
     * The id of the room.
     */
    readonly id: string;
    getConnectionState(): ConnectionState;
    subscribe: {
        /**
         * Subscribe to the current user presence updates.
         *
         * @param listener the callback that is called every time the current user presence is updated with {@link Room.updatePresence}.
         *
         * @example
         * room.subscribe("my-presence", (presence) => {
         *   // Do something
         * });
         */
        <T extends Presence>(type: "my-presence", listener: MyPresenceCallback<T>): () => void;
        /**
         * Subscribe to the other users updates.
         *
         * @param listener the callback that is called when a user enters or leaves the room or when a user update its presence.
         *
         * @example
         * room.subscribe("others", (others) => {
         *   // Do something
         * });
         */
        <T extends Presence>(type: "others", listener: OthersEventCallback<T>): () => void;
        /**
         * Subscribe to events broadcasted by {@link Room.broadcastEvent}
         *
         * @param listener the callback that is called when a user calls {@link Room.broadcastEvent}
         *
         * @example
         * room.subscribe("event", ({ event, connectionId }) => {
         *   // Do something
         * });
         */
        (type: "event", listener: EventCallback): () => void;
        /**
         * Subscribe to errors thrown in the room.
         */
        (type: "error", listener: ErrorCallback): () => void;
        /**
         * Subscribe to connection state updates.
         */
        (type: "connection", listener: ConnectionCallback): () => void;
        /**
         * Subscribes to changes made on a {@link LiveMap}. Returns an unsubscribe function.
         * In a future version, we will also expose what exactly changed in the {@link LiveMap}.
         *
         * @param listener the callback this called when the {@link LiveMap} changes.
         *
         * @returns Unsubscribe function.
         *
         * @example
         * const liveMap = new LiveMap();
         * const unsubscribe = room.subscribe(liveMap, (liveMap) => { });
         * unsubscribe();
         */
        <TKey extends string, TValue extends Lson>(liveMap: LiveMap<TKey, TValue>, listener: (liveMap: LiveMap<TKey, TValue>) => void): () => void;
        /**
         * Subscribes to changes made on a {@link LiveObject}. Returns an unsubscribe function.
         * In a future version, we will also expose what exactly changed in the {@link LiveObject}.
         *
         * @param listener the callback this called when the {@link LiveObject} changes.
         *
         * @returns Unsubscribe function.
         *
         * @example
         * const liveObject = new LiveObject();
         * const unsubscribe = room.subscribe(liveObject, (liveObject) => { });
         * unsubscribe();
         */
        <TData extends JsonObject>(liveObject: LiveObject<TData>, callback: (liveObject: LiveObject<TData>) => void): () => void;
        /**
         * Subscribes to changes made on a {@link LiveList}. Returns an unsubscribe function.
         * In a future version, we will also expose what exactly changed in the {@link LiveList}.
         *
         * @param listener the callback this called when the {@link LiveList} changes.
         *
         * @returns Unsubscribe function.
         *
         * @example
         * const liveList = new LiveList();
         * const unsubscribe = room.subscribe(liveList, (liveList) => { });
         * unsubscribe();
         */
        <TItem extends Lson>(liveList: LiveList<TItem>, callback: (liveList: LiveList<TItem>) => void): () => void;
        /**
         * Subscribes to changes made on a {@link LiveMap} and all the nested data structures. Returns an unsubscribe function.
         * In a future version, we will also expose what exactly changed in the {@link LiveMap}.
         *
         * @param listener the callback this called when the {@link LiveMap} changes.
         *
         * @returns Unsubscribe function.
         *
         * @example
         * const liveMap = new LiveMap();
         * const unsubscribe = room.subscribe(liveMap, (liveMap) => { }, { isDeep: true });
         * unsubscribe();
         */
        <TKey extends string, TValue extends Lson>(liveMap: LiveMap<TKey, TValue>, callback: (updates: LiveMapUpdates<TKey, TValue>[]) => void, options: {
            isDeep: true;
        }): () => void;
        /**
         * Subscribes to changes made on a {@link LiveObject} and all the nested data structures. Returns an unsubscribe function.
         * In a future version, we will also expose what exactly changed in the {@link LiveObject}.
         *
         * @param listener the callback this called when the {@link LiveObject} changes.
         *
         * @returns Unsubscribe function.
         *
         * @example
         * const liveObject = new LiveObject();
         * const unsubscribe = room.subscribe(liveObject, (liveObject) => { }, { isDeep: true });
         * unsubscribe();
         */
        <TData extends LsonObject>(liveObject: LiveObject<TData>, callback: (updates: LiveObjectUpdates<TData>[]) => void, options: {
            isDeep: true;
        }): () => void;
        /**
         * Subscribes to changes made on a {@link LiveList} and all the nested data structures. Returns an unsubscribe function.
         * In a future version, we will also expose what exactly changed in the {@link LiveList}.
         *
         * @param listener the callback this called when the {@link LiveList} changes.
         *
         * @returns Unsubscribe function.
         *
         * @example
         * const liveList = new LiveList();
         * const unsubscribe = room.subscribe(liveList, (liveList) => { }, { isDeep: true });
         * unsubscribe();
         */
        <TItem extends Lson>(liveList: LiveList<TItem>, callback: (updates: LiveListUpdates<TItem>[]) => void, options: {
            isDeep: true;
        }): () => void;
    };
    /**
     * Room's history contains functions that let you undo and redo operation made on by the current client on the presence and storage.
     */
    history: History;
    /**
     * @deprecated use the callback returned by subscribe instead.
     * See v0.13 release notes for more information.
     * Will be removed in a future version.
     */
    unsubscribe: {
        /**
         * @deprecated use the callback returned by subscribe instead.
         * See v0.13 release notes for more information.
         * Will be removed in a future version.
         */
        <T extends Presence>(type: "my-presence", listener: MyPresenceCallback<T>): void;
        /**
         * @deprecated use the callback returned by subscribe instead.
         * See v0.13 release notes for more information.
         * Will be removed in a future version.
         */
        <T extends Presence>(type: "others", listener: OthersEventCallback<T>): void;
        /**
         * @deprecated use the callback returned by subscribe instead.
         * See v0.13 release notes for more information.
         * Will be removed in a future version.
         */
        (type: "event", listener: EventCallback): void;
        /**
         * @deprecated use the callback returned by subscribe instead.
         * See v0.13 release notes for more information.
         * Will be removed in a future version.
         */
        (type: "error", listener: ErrorCallback): void;
        /**
         * @deprecated use the callback returned by subscribe instead.
         * See v0.13 release notes for more information.
         * Will be removed in a future version.
         */
        (type: "connection", listener: ConnectionCallback): void;
    };
    /**
     * Gets the current user.
     * Returns null if not it is not yet connected to the room.
     *
     * @example
     * const user = room.getSelf();
     */
    getSelf<TPresence extends Presence = Presence>(): User<TPresence> | null;
    /**
     * Gets the presence of the current user.
     *
     * @example
     * const presence = room.getPresence();
     */
    getPresence: <T extends Presence>() => T;
    /**
     * Gets all the other users in the room.
     *
     * @example
     * const others = room.getOthers();
     */
    getOthers: <T extends Presence>() => Others<T>;
    /**
     * Updates the presence of the current user. Only pass the properties you want to update. No need to send the full presence.
     * @param overrides A partial object that contains the properties you want to update.
     * @param overrides Optional object to configure the behavior of updatePresence.
     *
     * @example
     * room.updatePresence({ x: 0 });
     * room.updatePresence({ y: 0 });
     *
     * const presence = room.getPresence();
     * // presence is equivalent to { x: 0, y: 0 }
     */
    updatePresence: <T extends Presence>(overrides: Partial<T>, options?: {
        /**
         * Whether or not the presence should have an impact on the undo/redo history.
         */
        addToHistory: boolean;
    }) => void;
    /**
     * Broadcasts an event to other users in the room. Event broadcasted to the room can be listened with {@link Room.subscribe}("event").
     * @param {any} event the event to broadcast. Should be serializable to JSON
     *
     * @example
     * // On client A
     * room.broadcastEvent({ type: "EMOJI", emoji: "🔥" });
     *
     * // On client B
     * room.subscribe("event", ({ event }) => {
     *   if(event.type === "EMOJI") {
     *     // Do something
     *   }
     * });
     */
    broadcastEvent: (event: JsonObject, options?: BroadcastOptions) => void;
    /**
     * Get the room's storage asynchronously.
     * The storage's root is a {@link LiveObject}.
     *
     * @example
     * const { root } = await room.getStorage();
     */
    getStorage: <TStorage extends LsonObject>() => Promise<{
        root: LiveObject<TStorage>;
    }>;
    /**
     * Batches modifications made during the given function.
     * All the modifications are sent to other clients in a single message.
     * All the subscribers are called only after the batch is over.
     * All the modifications are merged in a single history item (undo/redo).
     *
     * @example
     * const { root } = await room.getStorage();
     * room.batch(() => {
     *   root.set("x", 0);
     *   room.updatePresence({ cursor: { x: 100, y: 100 }});
     * });
     */
    batch: (fn: () => void) => void;
};

declare abstract class AbstractCrdt {
    private __parent?;
    private __doc?;
    private __id?;
    private __parentKey?;
    get roomId(): string | null;
}

/**
 * The LiveObject class is similar to a JavaScript object that is synchronized on all clients.
 * Keys should be a string, and values should be serializable to JSON.
 * If multiple clients update the same property simultaneously, the last modification received by the Liveblocks servers is the winner.
 */
declare class LiveObject<O extends LsonObject = LsonObject> extends AbstractCrdt {
    private _map;
    private _propToLastUpdate;
    constructor(obj?: O);
    private _applyUpdate;
    private _applyDeleteObjectKey;
    /**
     * Transform the LiveObject into a javascript object
     */
    toObject(): O;
    /**
     * Adds or updates a property with a specified key and a value.
     * @param key The key of the property to add
     * @param value The value of the property to add
     */
    set<TKey extends keyof O>(key: TKey, value: O[TKey]): void;
    /**
     * Returns a specified property from the LiveObject.
     * @param key The key of the property to get
     */
    get<TKey extends keyof O>(key: TKey): O[TKey];
    /**
     * Deletes a key from the LiveObject
     * @param key The key of the property to delete
     */
    delete(key: keyof O): void;
    /**
     * Adds or updates multiple properties at once with an object.
     * @param overrides The object used to overrides properties
     */
    update(overrides: Partial<O>): void;
}

export { AbstractCrdt as A, BroadcastOptions as B, ClientOptions as C, History as H, Json as J, LiveObject as L, Others as O, Presence as P, Room as R, StorageUpdate as S, User as U, Client as a, LiveMap as b, LiveList as c, JsonObject as d, Lson as e, LsonObject as f, Resolve as g, RoomInitializers as h };
