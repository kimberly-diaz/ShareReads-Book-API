"use strict";

Object.defineProperty(exports, "__esModule", {
 value: !0
});

var LiveObject = require("./shared.js");

function lsonObjectToJson(obj) {
 var result = {};
 for (var _key in obj) {
  var val = obj[_key];
  void 0 !== val && (result[_key] = lsonToJson(val));
 }
 return result;
}

function lsonListToJson(value) {
 return value.map(lsonToJson);
}

function lsonToJson(value) {
 if (value instanceof LiveObject.LiveObject) return lsonObjectToJson(value.toObject());
 if (value instanceof LiveObject.LiveList) return function(value) {
  return lsonListToJson(value.toArray());
 }(value);
 if (value instanceof LiveObject.LiveMap) return function(map) {
  for (var _step, result = {}, _iterator = LiveObject._createForOfIteratorHelperLoose(map.entries()); !(_step = _iterator()).done; ) {
   var _step$value = _step.value, _key2 = _step$value[0], value = _step$value[1];
   result[_key2] = lsonToJson(value);
  }
  return result;
 }(value);
 if (value instanceof LiveObject.LiveRegister) return value.data;
 if (value instanceof LiveObject.AbstractCrdt) throw new Error("Unhandled subclass of AbstractCrdt encountered");
 return Array.isArray(value) ? lsonListToJson(value) : isPlainObject(value) ? lsonObjectToJson(value) : value;
}

function isPlainObject(obj) {
 return null !== obj && "[object Object]" === Object.prototype.toString.call(obj);
}

function anyToCrdt(obj) {
 if (null == obj) return obj;
 if (Array.isArray(obj)) return new LiveObject.LiveList(obj.map(anyToCrdt));
 if (isPlainObject(obj)) {
  var init = {};
  for (var _key3 in obj) init[_key3] = anyToCrdt(obj[_key3]);
  return new LiveObject.LiveObject(init);
 }
 return obj;
}

function patchLiveObjectKey(liveObject, key, prev, next) {
 if ("production" !== process.env.NODE_ENV) {
  var nonSerializableValue = LiveObject.findNonSerializableValue(next);
  if (nonSerializableValue) return void console.error("New state path: '" + nonSerializableValue.path + "' value: '" + nonSerializableValue.value + "' is not serializable.\nOnly serializable value can be synced with Liveblocks.");
 }
 var value = liveObject.get(key);
 if (void 0 === next) liveObject.delete(key); else if (void 0 === value) liveObject.set(key, anyToCrdt(next)); else {
  if (prev === next) return;
  value instanceof LiveObject.LiveList && Array.isArray(prev) && Array.isArray(next) ? function(liveList, prev, next) {
   var i = 0, prevEnd = prev.length - 1, nextEnd = next.length - 1, prevNode = prev[0], nextNode = next[0];
   outer: {
    for (;prevNode === nextNode; ) {
     if (++i > prevEnd || i > nextEnd) break outer;
     prevNode = prev[i], nextNode = next[i];
    }
    for (prevNode = prev[prevEnd], nextNode = next[nextEnd]; prevNode === nextNode; ) {
     if (nextEnd--, i > --prevEnd || i > nextEnd) break outer;
     prevNode = prev[prevEnd], nextNode = next[nextEnd];
    }
   }
   if (i > prevEnd) {
    if (i <= nextEnd) for (;i <= nextEnd; ) liveList.insert(anyToCrdt(next[i]), i), 
    i++;
   } else if (i > nextEnd) for (var localI = i; localI <= prevEnd; ) liveList.delete(i), 
   localI++; else {
    for (;i <= prevEnd && i <= nextEnd; ) {
     prevNode = prev[i], nextNode = next[i];
     var liveListNode = liveList.get(i);
     liveListNode instanceof LiveObject.LiveObject && isPlainObject(prevNode) && isPlainObject(nextNode) ? patchLiveObject(liveListNode, prevNode, nextNode) : liveList.set(i, anyToCrdt(nextNode)), 
     i++;
    }
    for (;i <= nextEnd; ) liveList.insert(anyToCrdt(next[i]), i), i++;
    for (var _localI = i; _localI <= prevEnd; ) liveList.delete(i), _localI++;
   }
  }(value, prev, next) : value instanceof LiveObject.LiveObject && isPlainObject(prev) && isPlainObject(next) ? patchLiveObject(value, prev, next) : liveObject.set(key, anyToCrdt(next));
 }
}

function patchLiveObject(root, prev, next) {
 var updates = {};
 for (var _key4 in next) patchLiveObjectKey(root, _key4, prev[_key4], next[_key4]);
 for (var _key5 in prev) void 0 === next[_key5] && root.delete(_key5);
 Object.keys(updates).length > 0 && root.update(updates);
}

function patchImmutableNode(state, path, update) {
 var _extends2, pathItem = path.pop();
 if (void 0 === pathItem) switch (update.type) {
 case "LiveObject":
  if ("object" != typeof state) throw new Error("Internal: received update on LiveObject but state was not an object");
  var newState = Object.assign({}, state);
  for (var _key6 in update.updates) {
   var _update$updates$_key, _update$updates$_key2;
   if ("update" === (null == (_update$updates$_key = update.updates[_key6]) ? void 0 : _update$updates$_key.type)) {
    var val = update.node.get(_key6);
    void 0 !== val && (newState[_key6] = lsonToJson(val));
   } else "delete" === (null == (_update$updates$_key2 = update.updates[_key6]) ? void 0 : _update$updates$_key2.type) && delete newState[_key6];
  }
  return newState;

 case "LiveList":
  if (!1 === Array.isArray(state)) throw new Error("Internal: received update on LiveList but state was not an array");
  for (var _step2, _newState = state.map((function(x) {
   return x;
  })), _loop = function() {
   var listUpdate = _step2.value;
   "set" === listUpdate.type ? _newState = _newState.map((function(item, index) {
    return index === listUpdate.index ? listUpdate.item : item;
   })) : "insert" === listUpdate.type ? listUpdate.index === _newState.length ? _newState.push(lsonToJson(listUpdate.item)) : _newState = [].concat(_newState.slice(0, listUpdate.index), [ lsonToJson(listUpdate.item) ], _newState.slice(listUpdate.index)) : "delete" === listUpdate.type ? _newState.splice(listUpdate.index, 1) : "move" === listUpdate.type && (_newState = listUpdate.previousIndex > listUpdate.index ? [].concat(_newState.slice(0, listUpdate.index), [ lsonToJson(listUpdate.item) ], _newState.slice(listUpdate.index, listUpdate.previousIndex), _newState.slice(listUpdate.previousIndex + 1)) : [].concat(_newState.slice(0, listUpdate.previousIndex), _newState.slice(listUpdate.previousIndex + 1, listUpdate.index + 1), [ lsonToJson(listUpdate.item) ], _newState.slice(listUpdate.index + 1)));
  }, _iterator2 = LiveObject._createForOfIteratorHelperLoose(update.updates); !(_step2 = _iterator2()).done; ) _loop();
  return _newState;

 case "LiveMap":
  if ("object" != typeof state) throw new Error("Internal: received update on LiveMap but state was not an object");
  var _newState2 = Object.assign({}, state);
  for (var _key7 in update.updates) {
   var _update$updates$_key3, _update$updates$_key4;
   "update" === (null == (_update$updates$_key3 = update.updates[_key7]) ? void 0 : _update$updates$_key3.type) ? _newState2[_key7] = lsonToJson(update.node.get(_key7)) : "delete" === (null == (_update$updates$_key4 = update.updates[_key7]) ? void 0 : _update$updates$_key4.type) && delete _newState2[_key7];
  }
  return _newState2;
 }
 if (Array.isArray(state)) {
  var newArray = [].concat(state);
  return newArray[pathItem] = patchImmutableNode(state[pathItem], path, update), newArray;
 }
 return LiveObject._extends({}, state, ((_extends2 = {})[pathItem] = patchImmutableNode(state[pathItem], path, update), 
 _extends2));
}

Object.defineProperty(exports, "ClientMsgCode", {
 enumerable: !0,
 get: function() {
  return LiveObject.ClientMsgCode;
 }
}), Object.defineProperty(exports, "CrdtType", {
 enumerable: !0,
 get: function() {
  return LiveObject.CrdtType;
 }
}), Object.defineProperty(exports, "OpCode", {
 enumerable: !0,
 get: function() {
  return LiveObject.OpCode;
 }
}), Object.defineProperty(exports, "ServerMsgCode", {
 enumerable: !0,
 get: function() {
  return LiveObject.ServerMsgCode;
 }
}), Object.defineProperty(exports, "WebsocketCloseCodes", {
 enumerable: !0,
 get: function() {
  return LiveObject.WebsocketCloseCodes;
 }
}), exports.comparePosition = LiveObject.comparePosition, exports.deprecate = LiveObject.deprecate, 
exports.deprecateIf = LiveObject.deprecateIf, exports.errorIf = LiveObject.errorIf, 
exports.makePosition = LiveObject.makePosition, exports.throwUsageError = LiveObject.throwUsageError, 
exports.lsonToJson = lsonToJson, exports.patchImmutableObject = function(state, updates) {
 return updates.reduce((function(state, update) {
  return function(state, update) {
   var path = function(node) {
    for (var path = []; null != node._parentKey && null != node._parent; ) node._parent instanceof LiveObject.LiveList ? path.push(node._parent._indexOfPosition(node._parentKey)) : path.push(node._parentKey), 
    node = node._parent;
    return path;
   }(update.node);
   return patchImmutableNode(state, path, update);
  }(state, update);
 }), state);
}, exports.patchLiveObjectKey = patchLiveObjectKey;
