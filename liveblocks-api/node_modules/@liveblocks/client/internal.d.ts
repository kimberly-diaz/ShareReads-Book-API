import { d as JsonObject, J as Json, e as Lson, A as AbstractCrdt, f as LsonObject, L as LiveObject, S as StorageUpdate } from './shared';
export { g as Resolve, h as RoomInitializers } from './shared';

/**
 * Messages that can be sent from the server to the client.
 */
declare type ServerMsg<TPresence extends JsonObject> = UpdatePresenceServerMsg<TPresence> | UserJoinServerMsg | UserLeftServerMsg | BroadcastedEventServerMsg | RoomStateServerMsg | InitialDocumentStateServerMsg | UpdateStorageServerMsg;
declare enum ServerMsgCode {
    UPDATE_PRESENCE = 100,
    USER_JOINED = 101,
    USER_LEFT = 102,
    BROADCASTED_EVENT = 103,
    ROOM_STATE = 104,
    INITIAL_STORAGE_STATE = 200,
    UPDATE_STORAGE = 201
}
/**
 * Sent by the WebSocket server to a single client in response to the client
 * joining the Room, to provide the initial state of the Room. The payload
 * includes a list of all other Users that already are in the Room.
 */
declare type RoomStateServerMsg = {
    type: ServerMsgCode.ROOM_STATE;
    users: {
        [actor: number]: {
            id?: string;
            info?: Json;
        };
    };
};
/**
 * Sent by the WebSocket server and broadcasted to all clients to announce that
 * a User updated their presence. For example, when a user moves their cursor.
 *
 * In most cases, the data payload will only include the fields from the
 * Presence that have been changed since the last announcement. However, after
 * a new user joins a room, a "full presence" will be announced so the newly
 * connected user will get each other's user full presence at least once. In
 * those cases, the `targetActor` field indicates the newly connected client,
 * so all other existing clients can ignore this broadcasted message.
 */
declare type UpdatePresenceServerMsg<TPresence extends JsonObject> = {
    type: ServerMsgCode.UPDATE_PRESENCE;
    /**
     * The User whose Presence has changed.
     */
    actor: number;
    /**
     * The partial or full Presence of a User. If the `targetActor` field is set,
     * this will be the full Presence, otherwise it only contain the fields that
     * have changed since the last broadcast.
     */
    data: TPresence;
    /**
     * If this message was sent in response to a newly joined user, this field
     * indicates which client this message is for. Other existing clients may
     * ignore this message if this message isn't targeted for them.
     */
    targetActor?: number;
};
/**
 * Sent by the WebSocket server and broadcasted to all clients to announce that
 * a new User has joined the Room.
 */
declare type UserJoinServerMsg = {
    type: ServerMsgCode.USER_JOINED;
    actor: number;
    /**
     * The id of the User that has been set in the authentication endpoint.
     * Useful to get additional information about the connected user.
     */
    id?: string;
    /**
     * Additional user information that has been set in the authentication
     * endpoint.
     */
    info?: Json;
};
/**
 * Sent by the WebSocket server and broadcasted to all clients to announce that
 * a new User has left the Room.
 */
declare type UserLeftServerMsg = {
    type: ServerMsgCode.USER_LEFT;
    actor: number;
};
/**
 * Sent by the WebSocket server and broadcasted to all clients to announce that
 * a User broadcasted an Event to everyone in the Room.
 */
declare type BroadcastedEventServerMsg = {
    type: ServerMsgCode.BROADCASTED_EVENT;
    /**
     * The User who broadcasted the Event.
     */
    actor: number;
    /**
     * The arbitrary payload of the Event. This can be any JSON value. Clients
     * will have to manually verify/decode this event.
     */
    event: Json;
};
declare type SerializedCrdtWithId = [id: string, crdt: SerializedCrdt];
/**
 * Sent by the WebSocket server to a single client in response to the client
 * joining the Room, to provide the initial Storage state of the Room. The
 * payload includes the entire Storage document.
 */
declare type InitialDocumentStateServerMsg = {
    type: ServerMsgCode.INITIAL_STORAGE_STATE;
    items: SerializedCrdtWithId[];
};
/**
 * Sent by the WebSocket server and broadcasted to all clients to announce that
 * a change occurred in the Storage document.
 *
 * The payload of this message contains a list of Ops (aka incremental
 * mutations to make to the initially loaded document).
 */
declare type UpdateStorageServerMsg = {
    type: ServerMsgCode.UPDATE_STORAGE;
    ops: Op[];
};
declare enum ClientMsgCode {
    UPDATE_PRESENCE = 100,
    BROADCAST_EVENT = 103,
    FETCH_STORAGE = 200,
    UPDATE_STORAGE = 201
}
declare enum CrdtType {
    OBJECT = 0,
    LIST = 1,
    MAP = 2,
    REGISTER = 3
}
declare type SerializedObject = {
    type: CrdtType.OBJECT;
    parentId?: string;
    parentKey?: string;
    data: JsonObject;
};
declare type SerializedList = {
    type: CrdtType.LIST;
    parentId: string;
    parentKey: string;
};
declare type SerializedMap = {
    type: CrdtType.MAP;
    parentId: string;
    parentKey: string;
};
declare type SerializedRegister = {
    type: CrdtType.REGISTER;
    parentId: string;
    parentKey: string;
    data: Json;
};
declare type SerializedCrdt = SerializedObject | SerializedList | SerializedMap | SerializedRegister;
declare enum OpCode {
    INIT = 0,
    SET_PARENT_KEY = 1,
    CREATE_LIST = 2,
    UPDATE_OBJECT = 3,
    CREATE_OBJECT = 4,
    DELETE_CRDT = 5,
    DELETE_OBJECT_KEY = 6,
    CREATE_MAP = 7,
    CREATE_REGISTER = 8
}
/**
 * These operations are the payload for {@link UpdateStorageServerMsg} messages
 * only.
 */
declare type Op = CreateObjectOp | UpdateObjectOp | DeleteCrdtOp | CreateListOp | SetParentKeyOp | DeleteObjectKeyOp | CreateMapOp | CreateRegisterOp;
declare type UpdateObjectOp = {
    opId?: string;
    id: string;
    type: OpCode.UPDATE_OBJECT;
    data: Partial<JsonObject>;
};
declare type CreateObjectOp = {
    opId?: string;
    id: string;
    intent?: "set";
    type: OpCode.CREATE_OBJECT;
    parentId?: string;
    parentKey?: string;
    data: JsonObject;
};
declare type CreateListOp = {
    opId?: string;
    id: string;
    intent?: "set";
    type: OpCode.CREATE_LIST;
    parentId: string;
    parentKey: string;
};
declare type CreateMapOp = {
    opId?: string;
    id: string;
    intent?: "set";
    type: OpCode.CREATE_MAP;
    parentId: string;
    parentKey: string;
};
declare type CreateRegisterOp = {
    opId?: string;
    id: string;
    intent?: "set";
    type: OpCode.CREATE_REGISTER;
    parentId: string;
    parentKey: string;
    data: Json;
};
declare type DeleteCrdtOp = {
    opId?: string;
    id: string;
    type: OpCode.DELETE_CRDT;
};
declare type SetParentKeyOp = {
    opId?: string;
    id: string;
    type: OpCode.SET_PARENT_KEY;
    parentKey: string;
};
declare type DeleteObjectKeyOp = {
    opId?: string;
    id: string;
    type: OpCode.DELETE_OBJECT_KEY;
    key: string;
};
declare enum WebsocketCloseCodes {
    CLOSE_ABNORMAL = 1006,
    INVALID_MESSAGE_FORMAT = 4000,
    NOT_ALLOWED = 4001,
    MAX_NUMBER_OF_MESSAGES_PER_SECONDS = 4002,
    MAX_NUMBER_OF_CONCURRENT_CONNECTIONS = 4003,
    MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP = 4004,
    MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM = 4005,
    CLOSE_WITHOUT_RETRY = 4999
}

/**
 * Tools to help with the controlled deprecation of public APIs.
 *
 * First warn, then error, then remove eventually.
 */
/**
 * Displays a deprecation warning in the dev console. Only in dev mode, and
 * only once per message/key. In production, this is a no-op.
 */
declare function deprecate(message: string, key?: string): void;
/**
 * Conditionally displays a deprecation warning in the dev
 * console if the first argument is truthy. Only in dev mode, and
 * only once per message/key. In production, this is a no-op.
 */
declare function deprecateIf(condition: unknown, message: string, key?: string): void;
/**
 * Throws a deprecation error in the dev console.
 *
 * Only triggers in dev mode. In production, this is a no-op.
 */
declare function throwUsageError(message: string): void;
/**
 * Conditionally throws a usage error in the dev console if the first argument
 * is truthy. Use this to "escalate" usage patterns that in previous versions
 * we already warned about with deprecation warnings.
 *
 * Only has effect in dev mode. In production, this is a no-op.
 */
declare function errorIf(condition: unknown, message: string): void;

declare function lsonToJson(value: Lson | AbstractCrdt): Json;
declare function patchLiveObjectKey<O extends LsonObject>(liveObject: LiveObject<O>, key: keyof O, prev: unknown, next: unknown): void;
declare function patchImmutableObject<T>(state: T, updates: StorageUpdate[]): T;

declare function makePosition(before?: string, after?: string): string;
declare function comparePosition(posA: string, posB: string): number;

export { ClientMsgCode, CrdtType, CreateListOp, CreateMapOp, CreateObjectOp, CreateRegisterOp, DeleteCrdtOp, DeleteObjectKeyOp, Op, OpCode, RoomStateServerMsg, SerializedCrdt, SerializedCrdtWithId, SerializedList, SerializedMap, SerializedObject, SerializedRegister, ServerMsg, ServerMsgCode, SetParentKeyOp, UpdateObjectOp, UserJoinServerMsg, WebsocketCloseCodes, comparePosition, deprecate, deprecateIf, errorIf, lsonToJson, makePosition, patchImmutableObject, patchLiveObjectKey, throwUsageError };
