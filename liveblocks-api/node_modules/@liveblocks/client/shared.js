"use strict";

function _defineProperties(target, props) {
 for (var i = 0; i < props.length; i++) {
  var descriptor = props[i];
  descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
  "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
 }
}

function _createClass(Constructor, protoProps, staticProps) {
 return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
 Object.defineProperty(Constructor, "prototype", {
  writable: !1
 }), Constructor;
}

function _extends() {
 return _extends = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
   var source = arguments[i];
   for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
  }
  return target;
 }, _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
 subClass.prototype = Object.create(superClass.prototype), subClass.prototype.constructor = subClass, 
 _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
 return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
  return o.__proto__ || Object.getPrototypeOf(o);
 }, _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
 return _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
  return o.__proto__ = p, o;
 }, _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
 if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
 if (Reflect.construct.sham) return !1;
 if ("function" == typeof Proxy) return !0;
 try {
  return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), 
  !0;
 } catch (e) {
  return !1;
 }
}

function _construct(Parent, args, Class) {
 return _construct = _isNativeReflectConstruct() ? Reflect.construct : function(Parent, args, Class) {
  var a = [ null ];
  a.push.apply(a, args);
  var instance = new (Function.bind.apply(Parent, a));
  return Class && _setPrototypeOf(instance, Class.prototype), instance;
 }, _construct.apply(null, arguments);
}

function _wrapNativeSuper(Class) {
 var _cache = "function" == typeof Map ? new Map : void 0;
 return _wrapNativeSuper = function(Class) {
  if (null === Class || (fn = Class, -1 === Function.toString.call(fn).indexOf("[native code]"))) return Class;
  var fn;
  if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
  if (void 0 !== _cache) {
   if (_cache.has(Class)) return _cache.get(Class);
   _cache.set(Class, Wrapper);
  }
  function Wrapper() {
   return _construct(Class, arguments, _getPrototypeOf(this).constructor);
  }
  return Wrapper.prototype = Object.create(Class.prototype, {
   constructor: {
    value: Wrapper,
    enumerable: !1,
    writable: !0,
    configurable: !0
   }
  }), _setPrototypeOf(Wrapper, Class);
 }, _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
 if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
 return self;
}

function _arrayLikeToArray(arr, len) {
 (null == len || len > arr.length) && (len = arr.length);
 for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
 return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
 var it = "undefined" != typeof Symbol && o[Symbol.iterator] || o["@@iterator"];
 if (it) return (it = it.call(o)).next.bind(it);
 if (Array.isArray(o) || (it = function(o, minLen) {
  if (o) {
   if ("string" == typeof o) return _arrayLikeToArray(o, minLen);
   var n = Object.prototype.toString.call(o).slice(8, -1);
   return "Object" === n && o.constructor && (n = o.constructor.name), "Map" === n || "Set" === n ? Array.from(o) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray(o, minLen) : void 0;
  }
 }(o)) || allowArrayLike && o && "number" == typeof o.length) {
  it && (o = it);
  var i = 0;
  return function() {
   return i >= o.length ? {
    done: !0
   } : {
    done: !1,
    value: o[i++]
   };
  };
 }
 throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var ServerMsgCode, ClientMsgCode, CrdtType, OpCode, WebsocketCloseCodes;

exports.ServerMsgCode = void 0, (ServerMsgCode = exports.ServerMsgCode || (exports.ServerMsgCode = {}))[ServerMsgCode.UPDATE_PRESENCE = 100] = "UPDATE_PRESENCE", 
ServerMsgCode[ServerMsgCode.USER_JOINED = 101] = "USER_JOINED", ServerMsgCode[ServerMsgCode.USER_LEFT = 102] = "USER_LEFT", 
ServerMsgCode[ServerMsgCode.BROADCASTED_EVENT = 103] = "BROADCASTED_EVENT", ServerMsgCode[ServerMsgCode.ROOM_STATE = 104] = "ROOM_STATE", 
ServerMsgCode[ServerMsgCode.INITIAL_STORAGE_STATE = 200] = "INITIAL_STORAGE_STATE", 
ServerMsgCode[ServerMsgCode.UPDATE_STORAGE = 201] = "UPDATE_STORAGE", exports.ClientMsgCode = void 0, 
(ClientMsgCode = exports.ClientMsgCode || (exports.ClientMsgCode = {}))[ClientMsgCode.UPDATE_PRESENCE = 100] = "UPDATE_PRESENCE", 
ClientMsgCode[ClientMsgCode.BROADCAST_EVENT = 103] = "BROADCAST_EVENT", ClientMsgCode[ClientMsgCode.FETCH_STORAGE = 200] = "FETCH_STORAGE", 
ClientMsgCode[ClientMsgCode.UPDATE_STORAGE = 201] = "UPDATE_STORAGE", exports.CrdtType = void 0, 
(CrdtType = exports.CrdtType || (exports.CrdtType = {}))[CrdtType.OBJECT = 0] = "OBJECT", 
CrdtType[CrdtType.LIST = 1] = "LIST", CrdtType[CrdtType.MAP = 2] = "MAP", CrdtType[CrdtType.REGISTER = 3] = "REGISTER", 
exports.OpCode = void 0, (OpCode = exports.OpCode || (exports.OpCode = {}))[OpCode.INIT = 0] = "INIT", 
OpCode[OpCode.SET_PARENT_KEY = 1] = "SET_PARENT_KEY", OpCode[OpCode.CREATE_LIST = 2] = "CREATE_LIST", 
OpCode[OpCode.UPDATE_OBJECT = 3] = "UPDATE_OBJECT", OpCode[OpCode.CREATE_OBJECT = 4] = "CREATE_OBJECT", 
OpCode[OpCode.DELETE_CRDT = 5] = "DELETE_CRDT", OpCode[OpCode.DELETE_OBJECT_KEY = 6] = "DELETE_OBJECT_KEY", 
OpCode[OpCode.CREATE_MAP = 7] = "CREATE_MAP", OpCode[OpCode.CREATE_REGISTER = 8] = "CREATE_REGISTER", 
exports.WebsocketCloseCodes = void 0, (WebsocketCloseCodes = exports.WebsocketCloseCodes || (exports.WebsocketCloseCodes = {}))[WebsocketCloseCodes.CLOSE_ABNORMAL = 1006] = "CLOSE_ABNORMAL", 
WebsocketCloseCodes[WebsocketCloseCodes.INVALID_MESSAGE_FORMAT = 4e3] = "INVALID_MESSAGE_FORMAT", 
WebsocketCloseCodes[WebsocketCloseCodes.NOT_ALLOWED = 4001] = "NOT_ALLOWED", WebsocketCloseCodes[WebsocketCloseCodes.MAX_NUMBER_OF_MESSAGES_PER_SECONDS = 4002] = "MAX_NUMBER_OF_MESSAGES_PER_SECONDS", 
WebsocketCloseCodes[WebsocketCloseCodes.MAX_NUMBER_OF_CONCURRENT_CONNECTIONS = 4003] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS", 
WebsocketCloseCodes[WebsocketCloseCodes.MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP = 4004] = "MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP", 
WebsocketCloseCodes[WebsocketCloseCodes.MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM = 4005] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM", 
WebsocketCloseCodes[WebsocketCloseCodes.CLOSE_WITHOUT_RETRY = 4999] = "CLOSE_WITHOUT_RETRY";

var AbstractCrdt = function() {
 function AbstractCrdt() {
  this.__parent = void 0, this.__doc = void 0, this.__id = void 0, this.__parentKey = void 0;
 }
 var _proto = AbstractCrdt.prototype;
 return _proto._apply = function(op, _isLocal) {
  return op.type === exports.OpCode.DELETE_CRDT && null != this._parent && null != this._parentKey ? this._parent._detachChild(this) : {
   modified: !1
  };
 }, _proto._setParentLink = function(parent, key) {
  if (null != this.__parent && this.__parent !== parent) throw new Error("Cannot attach parent if it already exist");
  this.__parentKey = key, this.__parent = parent;
 }, _proto._attach = function(id, doc) {
  if (this.__id || this.__doc) throw new Error("Cannot attach if CRDT is already attached");
  doc.addItem(id, this), this.__id = id, this.__doc = doc;
 }, _proto._detach = function() {
  this.__doc && this.__id && this.__doc.deleteItem(this.__id), this.__parent = void 0, 
  this.__doc = void 0;
 }, _createClass(AbstractCrdt, [ {
  key: "_doc",
  get: function() {
   return this.__doc;
  }
 }, {
  key: "roomId",
  get: function() {
   return this.__doc ? this.__doc.roomId : null;
  }
 }, {
  key: "_id",
  get: function() {
   return this.__id;
  }
 }, {
  key: "_parent",
  get: function() {
   return this.__parent;
  }
 }, {
  key: "_parentKey",
  get: function() {
   return this.__parentKey;
  }
 } ]), AbstractCrdt;
}();

function parseJson(rawMessage) {
 try {
  return JSON.parse(rawMessage);
 } catch (e) {
  return;
 }
}

function isJsonArray(data) {
 return Array.isArray(data);
}

function isJsonObject(data) {
 return null !== data && "object" == typeof data && !isJsonArray(data);
}

var _Symbol$iterator$1, _Symbol$iterator2, LiveRegister = function(_AbstractCrdt) {
 function LiveRegister(data) {
  var _this;
  return (_this = _AbstractCrdt.call(this) || this)._data = void 0, _this._data = data, 
  _this;
 }
 _inheritsLoose(LiveRegister, _AbstractCrdt), LiveRegister._deserialize = function(_ref, _parentToChildren, doc) {
  var id = _ref[0], item = _ref[1];
  if (item.type !== exports.CrdtType.REGISTER) throw new Error('Tried to deserialize a map but item type is "' + item.type + '"');
  var register = new LiveRegister(item.data);
  return register._attach(id, doc), register;
 };
 var _proto = LiveRegister.prototype;
 return _proto._serialize = function(parentId, parentKey, doc, intent) {
  if (null == this._id || null == parentId || null == parentKey) throw new Error("Cannot serialize register if parentId or parentKey is undefined");
  return [ {
   type: exports.OpCode.CREATE_REGISTER,
   opId: null == doc ? void 0 : doc.generateOpId(),
   id: this._id,
   intent: intent,
   parentId: parentId,
   parentKey: parentKey,
   data: this.data
  } ];
 }, _proto._toSerializedCrdt = function() {
  var _this$_parent;
  return {
   type: exports.CrdtType.REGISTER,
   parentId: null == (_this$_parent = this._parent) ? void 0 : _this$_parent._id,
   parentKey: this._parentKey,
   data: this.data
  };
 }, _proto._attachChild = function(_op, _isLocal) {
  throw new Error("Method not implemented.");
 }, _proto._detachChild = function(_crdt) {
  throw new Error("Method not implemented.");
 }, _proto._apply = function(op, isLocal) {
  return _AbstractCrdt.prototype._apply.call(this, op, isLocal);
 }, _createClass(LiveRegister, [ {
  key: "data",
  get: function() {
   return this._data;
  }
 } ]), LiveRegister;
}(AbstractCrdt);

function makePosition(before, after) {
 return null == before && null == after ? pos([ 33 ]) : null != before && null == after ? function(before) {
  for (var result = [], beforeCodes = posCodes(before), i = 0; i < beforeCodes.length; i++) {
   var code = beforeCodes[i];
   if (126 !== code) {
    result.push(code + 1);
    break;
   }
   if (result.push(code), beforeCodes.length - 1 === i) {
    result.push(33);
    break;
   }
  }
  return pos(result);
 }(before) : null == before && null != after ? function(after) {
  for (var result = [], afterCodes = posCodes(after), i = 0; i < afterCodes.length; i++) {
   var code = afterCodes[i];
   if (!(code <= 33)) {
    result.push(code - 1);
    break;
   }
   if (result.push(32), afterCodes.length - 1 === i) {
    result.push(126);
    break;
   }
  }
  return pos(result);
 }(after) : pos(makePositionFromCodes(posCodes(before), posCodes(after)));
}

function makePositionFromCodes(before, after) {
 for (var index = 0, result = []; ;) {
  var beforeDigit = before[index] || 32, afterDigit = after[index] || 126;
  if (beforeDigit > afterDigit) throw new Error("Impossible to generate position between " + before + " and " + after);
  if (beforeDigit !== afterDigit) {
   if (afterDigit - beforeDigit == 1) {
    result.push(beforeDigit), result.push.apply(result, makePositionFromCodes(before.slice(index + 1), []));
    break;
   }
   var mid = afterDigit + beforeDigit >> 1;
   result.push(mid);
   break;
  }
  result.push(beforeDigit), index++;
 }
 return result;
}

function posCodes(str) {
 for (var codes = [], i = 0; i < str.length; i++) codes.push(str.charCodeAt(i));
 return codes;
}

function pos(codes) {
 return String.fromCharCode.apply(String, codes);
}

function comparePosition(posA, posB) {
 for (var aCodes = posCodes(posA), bCodes = posCodes(posB), maxLength = Math.max(aCodes.length, bCodes.length), i = 0; i < maxLength; i++) {
  var a = null == aCodes[i] ? 32 : aCodes[i], b = null == bCodes[i] ? 32 : bCodes[i];
  if (a !== b) return a - b;
 }
 throw new Error('Impossible to compare similar position "' + posA + '" and "' + posB + '"');
}

_Symbol$iterator$1 = Symbol.iterator;

var LiveList = function(_AbstractCrdt) {
 function LiveList(items) {
  var _this;
  void 0 === items && (items = []), (_this = _AbstractCrdt.call(this) || this)._items = void 0, 
  _this._items = [];
  for (var position = void 0, i = 0; i < items.length; i++) {
   var newPosition = makePosition(position), _item = selfOrRegister(items[i]);
   _this._items.push([ _item, newPosition ]), position = newPosition;
  }
  return _this;
 }
 _inheritsLoose(LiveList, _AbstractCrdt), LiveList._deserialize = function(_ref, parentToChildren, doc) {
  var id = _ref[0], list = new LiveList([]);
  list._attach(id, doc);
  var children = parentToChildren.get(id);
  if (null == children) return list;
  for (var _step, _iterator = _createForOfIteratorHelperLoose(children); !(_step = _iterator()).done; ) {
   var entry = _step.value, child = deserialize(entry, parentToChildren, doc);
   child._setParentLink(list, entry[1].parentKey), list._items.push([ child, entry[1].parentKey ]), 
   list._items.sort((function(itemA, itemB) {
    return comparePosition(itemA[1], itemB[1]);
   }));
  }
  return list;
 };
 var _proto = LiveList.prototype;
 return _proto._serialize = function(parentId, parentKey, doc, intent) {
  if (null == this._id) throw new Error("Cannot serialize item is not attached");
  if (null == parentId || null == parentKey) throw new Error("Cannot serialize list if parentId or parentKey is undefined");
  var ops = [], op = {
   id: this._id,
   opId: null == doc ? void 0 : doc.generateOpId(),
   intent: intent,
   type: exports.OpCode.CREATE_LIST,
   parentId: parentId,
   parentKey: parentKey
  };
  ops.push(op);
  for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(this._items); !(_step2 = _iterator2()).done; ) {
   var _step2$value = _step2.value, _value = _step2$value[0], key = _step2$value[1];
   ops.push.apply(ops, _value._serialize(this._id, key, doc));
  }
  return ops;
 }, _proto._indexOfPosition = function(position) {
  return this._items.findIndex((function(item) {
   return item[1] === position;
  }));
 }, _proto._attach = function(id, doc) {
  _AbstractCrdt.prototype._attach.call(this, id, doc);
  for (var _step3, _iterator3 = _createForOfIteratorHelperLoose(this._items); !(_step3 = _iterator3()).done; ) {
   _step3.value[0]._attach(doc.generateId(), doc);
  }
 }, _proto._detach = function() {
  _AbstractCrdt.prototype._detach.call(this);
  for (var _step4, _iterator4 = _createForOfIteratorHelperLoose(this._items); !(_step4 = _iterator4()).done; ) {
   _step4.value[0]._detach();
  }
 }, _proto._attachChild = function(op, isLocal) {
  if (null == this._doc) throw new Error("Can't attach child if doc is not present");
  var id = op.id, parentKey = op.parentKey, intent = op.intent, key = parentKey, child = creationOpToLiveStructure(op);
  if (void 0 !== this._doc.getItem(id)) return {
   modified: !1
  };
  child._attach(id, this._doc), child._setParentLink(this, key);
  var index = this._items.findIndex((function(entry) {
   return entry[1] === key;
  })), newKey = key;
  if (-1 !== index) {
   if ("set" === intent) {
    var existingItem = this._items[index][0];
    existingItem._detach();
    var storageUpdate = {
     node: this,
     type: "LiveList",
     updates: [ {
      index: index,
      type: "set",
      item: child instanceof LiveRegister ? child.data : child
     } ]
    };
    return this._items[index][0] = child, {
     modified: storageUpdate,
     reverse: existingItem._serialize(this._id, key, this._doc, "set")
    };
   }
   if (isLocal) {
    var before = this._items[index] ? this._items[index][1] : void 0, after = this._items[index + 1] ? this._items[index + 1][1] : void 0;
    newKey = makePosition(before, after), child._setParentLink(this, newKey);
   } else {
    var _this$_items;
    this._items[index][1] = makePosition(key, null == (_this$_items = this._items[index + 1]) ? void 0 : _this$_items[1]);
   }
  }
  this._items.push([ child, newKey ]), this._items.sort((function(itemA, itemB) {
   return comparePosition(itemA[1], itemB[1]);
  }));
  var newIndex = this._items.findIndex((function(entry) {
   return entry[1] === newKey;
  }));
  return {
   reverse: [ {
    type: exports.OpCode.DELETE_CRDT,
    id: id
   } ],
   modified: {
    node: this,
    type: "LiveList",
    updates: [ {
     index: newIndex,
     type: "insert",
     item: child instanceof LiveRegister ? child.data : child
    } ]
   }
  };
 }, _proto._detachChild = function(child) {
  if (child) {
   var reverse = child._serialize(this._id, child._parentKey, this._doc), indexToDelete = this._items.findIndex((function(item) {
    return item[0] === child;
   }));
   return this._items.splice(indexToDelete, 1), child._detach(), {
    modified: {
     node: this,
     type: "LiveList",
     updates: [ {
      index: indexToDelete,
      type: "delete"
     } ]
    },
    reverse: reverse
   };
  }
  return {
   modified: !1
  };
 }, _proto._setChildKey = function(key, child, previousKey) {
  child._setParentLink(this, key);
  var _this$_items2, previousIndex = this._items.findIndex((function(entry) {
   return entry[0]._id === child._id;
  })), index = this._items.findIndex((function(entry) {
   return entry[1] === key;
  }));
  -1 !== index && (this._items[index][1] = makePosition(key, null == (_this$_items2 = this._items[index + 1]) ? void 0 : _this$_items2[1]));
  var item = this._items.find((function(item) {
   return item[0] === child;
  }));
  item && (item[1] = key), this._items.sort((function(itemA, itemB) {
   return comparePosition(itemA[1], itemB[1]);
  }));
  var newIndex = this._items.findIndex((function(entry) {
   return entry[0]._id === child._id;
  }));
  return {
   modified: {
    node: this,
    type: "LiveList",
    updates: newIndex === previousIndex ? [] : [ {
     index: newIndex,
     item: child instanceof LiveRegister ? child.data : child,
     previousIndex: previousIndex,
     type: "move"
    } ]
   },
   reverse: [ {
    type: exports.OpCode.SET_PARENT_KEY,
    id: null == item ? void 0 : item[0]._id,
    parentKey: previousKey
   } ]
  };
 }, _proto._apply = function(op, isLocal) {
  return _AbstractCrdt.prototype._apply.call(this, op, isLocal);
 }, _proto._toSerializedCrdt = function() {
  var _this$_parent;
  return {
   type: exports.CrdtType.LIST,
   parentId: null == (_this$_parent = this._parent) ? void 0 : _this$_parent._id,
   parentKey: this._parentKey
  };
 }, _proto.push = function(element) {
  return this.insert(element, this.length);
 }, _proto.insert = function(element, index) {
  if (index < 0 || index > this._items.length) throw new Error('Cannot insert list item at index "' + index + '". index should be between 0 and ' + this._items.length);
  var position = makePosition(this._items[index - 1] ? this._items[index - 1][1] : void 0, this._items[index] ? this._items[index][1] : void 0), value = selfOrRegister(element);
  value._setParentLink(this, position), this._items.push([ value, position ]), this._items.sort((function(itemA, itemB) {
   return comparePosition(itemA[1], itemB[1]);
  }));
  var newIndex = this._items.findIndex((function(entry) {
   return entry[1] === position;
  }));
  if (this._doc && this._id) {
   var _id = this._doc.generateId();
   value._attach(_id, this._doc);
   var storageUpdates = new Map;
   storageUpdates.set(this._id, {
    node: this,
    type: "LiveList",
    updates: [ {
     index: newIndex,
     item: value instanceof LiveRegister ? value.data : value,
     type: "insert"
    } ]
   }), this._doc.dispatch(value._serialize(this._id, position, this._doc), [ {
    type: exports.OpCode.DELETE_CRDT,
    id: _id
   } ], storageUpdates);
  }
 }, _proto.move = function(index, targetIndex) {
  if (targetIndex < 0) throw new Error("targetIndex cannot be less than 0");
  if (targetIndex >= this._items.length) throw new Error("targetIndex cannot be greater or equal than the list length");
  if (index < 0) throw new Error("index cannot be less than 0");
  if (index >= this._items.length) throw new Error("index cannot be greater or equal than the list length");
  var beforePosition = null, afterPosition = null;
  index < targetIndex ? (afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1][1], 
  beforePosition = this._items[targetIndex][1]) : (afterPosition = this._items[targetIndex][1], 
  beforePosition = 0 === targetIndex ? void 0 : this._items[targetIndex - 1][1]);
  var position = makePosition(beforePosition, afterPosition), item = this._items[index], previousPosition = item[1];
  item[1] = position, item[0]._setParentLink(this, position), this._items.sort((function(itemA, itemB) {
   return comparePosition(itemA[1], itemB[1]);
  }));
  var newIndex = this._items.findIndex((function(entry) {
   return entry[1] === position;
  }));
  if (this._doc && this._id) {
   var storageUpdates = new Map;
   storageUpdates.set(this._id, {
    node: this,
    type: "LiveList",
    updates: [ {
     index: newIndex,
     previousIndex: index,
     item: item[0],
     type: "move"
    } ]
   }), this._doc.dispatch([ {
    type: exports.OpCode.SET_PARENT_KEY,
    id: item[0]._id,
    opId: this._doc.generateOpId(),
    parentKey: position
   } ], [ {
    type: exports.OpCode.SET_PARENT_KEY,
    id: item[0]._id,
    parentKey: previousPosition
   } ], storageUpdates);
  }
 }, _proto.delete = function(index) {
  if (index < 0 || index >= this._items.length) throw new Error('Cannot delete list item at index "' + index + '". index should be between 0 and ' + (this._items.length - 1));
  var item = this._items[index];
  if (item[0]._detach(), this._items.splice(index, 1), this._doc) {
   var childRecordId = item[0]._id;
   if (childRecordId) {
    var storageUpdates = new Map;
    storageUpdates.set(this._id, {
     node: this,
     type: "LiveList",
     updates: [ {
      index: index,
      type: "delete"
     } ]
    }), this._doc.dispatch([ {
     id: childRecordId,
     opId: this._doc.generateOpId(),
     type: exports.OpCode.DELETE_CRDT
    } ], item[0]._serialize(this._id, item[1]), storageUpdates);
   }
  }
 }, _proto.clear = function() {
  if (this._doc) {
   for (var _step5, ops = [], reverseOps = [], updateDelta = [], i = 0, _iterator5 = _createForOfIteratorHelperLoose(this._items); !(_step5 = _iterator5()).done; ) {
    var _item3 = _step5.value;
    _item3[0]._detach();
    var childId = _item3[0]._id;
    childId && (ops.push({
     id: childId,
     type: exports.OpCode.DELETE_CRDT
    }), reverseOps.push.apply(reverseOps, _item3[0]._serialize(this._id, _item3[1])), 
    updateDelta.push({
     index: i,
     type: "delete"
    })), i++;
   }
   this._items = [];
   var storageUpdates = new Map;
   storageUpdates.set(this._id, {
    node: this,
    type: "LiveList",
    updates: updateDelta
   }), this._doc.dispatch(ops, reverseOps, storageUpdates);
  } else {
   for (var _step6, _iterator6 = _createForOfIteratorHelperLoose(this._items); !(_step6 = _iterator6()).done; ) {
    _step6.value[0]._detach();
   }
   this._items = [];
  }
 }, _proto.set = function(index, item) {
  if (index < 0 || index >= this._items.length) throw new Error('Cannot set list item at index "' + index + '". index should be between 0 and ' + (this._items.length - 1));
  var _this$_items$index = this._items[index], existingItem = _this$_items$index[0], position = _this$_items$index[1];
  existingItem._detach();
  var value = selfOrRegister(item);
  if (value._setParentLink(this, position), this._items[index][0] = value, this._doc && this._id) {
   var _id2 = this._doc.generateId();
   value._attach(_id2, this._doc);
   var storageUpdates = new Map;
   storageUpdates.set(this._id, {
    node: this,
    type: "LiveList",
    updates: [ {
     index: index,
     item: value instanceof LiveRegister ? value.data : value,
     type: "set"
    } ]
   }), this._doc.dispatch(value._serialize(this._id, position, this._doc, "set"), existingItem._serialize(this._id, position, void 0, "set"), storageUpdates);
  }
 }, _proto.toArray = function() {
  return this._items.map((function(entry) {
   return selfOrRegisterValue(entry[0]);
  }));
 }, _proto.every = function(predicate) {
  return this.toArray().every(predicate);
 }, _proto.filter = function(predicate) {
  return this.toArray().filter(predicate);
 }, _proto.find = function(predicate) {
  return this.toArray().find(predicate);
 }, _proto.findIndex = function(predicate) {
  return this.toArray().findIndex(predicate);
 }, _proto.forEach = function(callbackfn) {
  return this.toArray().forEach(callbackfn);
 }, _proto.get = function(index) {
  if (!(index < 0 || index >= this._items.length)) return selfOrRegisterValue(this._items[index][0]);
 }, _proto.indexOf = function(searchElement, fromIndex) {
  return this.toArray().indexOf(searchElement, fromIndex);
 }, _proto.lastIndexOf = function(searchElement, fromIndex) {
  return this.toArray().lastIndexOf(searchElement, fromIndex);
 }, _proto.map = function(callback) {
  return this._items.map((function(entry, i) {
   return callback(selfOrRegisterValue(entry[0]), i);
  }));
 }, _proto.some = function(predicate) {
  return this.toArray().some(predicate);
 }, _proto[_Symbol$iterator$1] = function() {
  return new LiveListIterator(this._items);
 }, _createClass(LiveList, [ {
  key: "length",
  get: function() {
   return this._items.length;
  }
 } ]), LiveList;
}(AbstractCrdt);

_Symbol$iterator2 = Symbol.iterator;

var _Symbol$iterator, LiveListIterator = function() {
 function LiveListIterator(items) {
  this._innerIterator = void 0, this._innerIterator = items[Symbol.iterator]();
 }
 var _proto2 = LiveListIterator.prototype;
 return _proto2[_Symbol$iterator2] = function() {
  return this;
 }, _proto2.next = function() {
  var result = this._innerIterator.next();
  return result.done ? {
   done: !0,
   value: void 0
  } : {
   value: selfOrRegisterValue(result.value[0])
  };
 }, LiveListIterator;
}(), _emittedDeprecationWarnings = new Set;

function deprecate(message, key) {
 void 0 === key && (key = message), "production" !== process.env.NODE_ENV && (_emittedDeprecationWarnings.has(key) || (_emittedDeprecationWarnings.add(key), 
 console.error("DEPRECATION WARNING: " + message)));
}

function deprecateIf(condition, message, key) {
 void 0 === key && (key = message), "production" !== process.env.NODE_ENV && condition && deprecate(message, key);
}

function throwUsageError(message) {
 if ("production" !== process.env.NODE_ENV) {
  var usageError = new Error(message);
  throw usageError.name = "Usage error", usageError;
 }
}

_Symbol$iterator = Symbol.iterator;

var LiveMap = function(_AbstractCrdt) {
 function LiveMap(entries) {
  var _this;
  if ((_this = _AbstractCrdt.call(this) || this)._map = void 0, deprecateIf(null === entries, "Support for calling `new LiveMap(null)` will be removed in @liveblocks/client 0.18. Please call as `new LiveMap()`, or `new LiveMap([])`."), 
  entries) {
   for (var _step, mappedEntries = [], _iterator = _createForOfIteratorHelperLoose(entries); !(_step = _iterator()).done; ) {
    var entry = _step.value, _value = selfOrRegister(entry[1]);
    _value._setParentLink(_assertThisInitialized(_this), entry[0]), mappedEntries.push([ entry[0], _value ]);
   }
   _this._map = new Map(mappedEntries);
  } else _this._map = new Map;
  return _this;
 }
 _inheritsLoose(LiveMap, _AbstractCrdt);
 var _proto = LiveMap.prototype;
 return _proto._serialize = function(parentId, parentKey, doc, intent) {
  if (null == this._id) throw new Error("Cannot serialize item is not attached");
  if (null == parentId || null == parentKey) throw new Error("Cannot serialize map if parentId or parentKey is undefined");
  var ops = [], op = {
   id: this._id,
   opId: null == doc ? void 0 : doc.generateOpId(),
   type: exports.OpCode.CREATE_MAP,
   intent: intent,
   parentId: parentId,
   parentKey: parentKey
  };
  ops.push(op);
  for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(this._map); !(_step2 = _iterator2()).done; ) {
   var _step2$value = _step2.value, _key2 = _step2$value[0], _value2 = _step2$value[1];
   ops.push.apply(ops, _value2._serialize(this._id, _key2, doc));
  }
  return ops;
 }, LiveMap._deserialize = function(_ref, parentToChildren, doc) {
  var id = _ref[0], item = _ref[1];
  if (item.type !== exports.CrdtType.MAP) throw new Error('Tried to deserialize a map but item type is "' + item.type + '"');
  var map = new LiveMap;
  map._attach(id, doc);
  var children = parentToChildren.get(id);
  if (null == children) return map;
  for (var _step3, _iterator3 = _createForOfIteratorHelperLoose(children); !(_step3 = _iterator3()).done; ) {
   var entry = _step3.value, crdt = entry[1];
   if (null == crdt.parentKey) throw new Error("Tried to deserialize a crdt but it does not have a parentKey and is not the root");
   var child = deserialize(entry, parentToChildren, doc);
   child._setParentLink(map, crdt.parentKey), map._map.set(crdt.parentKey, child);
  }
  return map;
 }, _proto._attach = function(id, doc) {
  _AbstractCrdt.prototype._attach.call(this, id, doc);
  for (var _step4, _iterator4 = _createForOfIteratorHelperLoose(this._map); !(_step4 = _iterator4()).done; ) {
   var _step4$value = _step4.value;
   _step4$value[0];
   var _value3 = _step4$value[1];
   isCrdt(_value3) && _value3._attach(doc.generateId(), doc);
  }
 }, _proto._attachChild = function(op, _isLocal) {
  var _updates;
  if (null == this._doc) throw new Error("Can't attach child if doc is not present");
  var id = op.id, key = op.parentKey, child = creationOpToLiveStructure(op);
  if (void 0 !== this._doc.getItem(id)) return {
   modified: !1
  };
  var reverse, previousValue = this._map.get(key);
  return previousValue ? (reverse = previousValue._serialize(this._id, key), previousValue._detach()) : reverse = [ {
   type: exports.OpCode.DELETE_CRDT,
   id: id
  } ], child._setParentLink(this, key), child._attach(id, this._doc), this._map.set(key, child), 
  {
   modified: {
    node: this,
    type: "LiveMap",
    updates: (_updates = {}, _updates[key] = {
     type: "update"
    }, _updates)
   },
   reverse: reverse
  };
 }, _proto._detach = function() {
  _AbstractCrdt.prototype._detach.call(this);
  for (var _step5, _iterator5 = _createForOfIteratorHelperLoose(this._map.values()); !(_step5 = _iterator5()).done; ) {
   _step5.value._detach();
  }
 }, _proto._detachChild = function(child) {
  for (var _updates2, _step6, reverse = child._serialize(this._id, child._parentKey, this._doc), _iterator6 = _createForOfIteratorHelperLoose(this._map); !(_step6 = _iterator6()).done; ) {
   var _step6$value = _step6.value, _key3 = _step6$value[0];
   _step6$value[1] === child && this._map.delete(_key3);
  }
  return child._detach(), {
   modified: {
    node: this,
    type: "LiveMap",
    updates: (_updates2 = {}, _updates2[child._parentKey] = {
     type: "delete"
    }, _updates2)
   },
   reverse: reverse
  };
 }, _proto._toSerializedCrdt = function() {
  var _this$_parent;
  return {
   type: exports.CrdtType.MAP,
   parentId: null == (_this$_parent = this._parent) ? void 0 : _this$_parent._id,
   parentKey: this._parentKey
  };
 }, _proto.get = function(key) {
  var value = this._map.get(key);
  if (null != value) return selfOrRegisterValue(value);
 }, _proto.set = function(key, value) {
  var oldValue = this._map.get(key);
  oldValue && oldValue._detach();
  var item = selfOrRegister(value);
  if (item._setParentLink(this, key), this._map.set(key, item), this._doc && this._id) {
   var _updates3, id = this._doc.generateId();
   item._attach(id, this._doc);
   var storageUpdates = new Map;
   storageUpdates.set(this._id, {
    node: this,
    type: "LiveMap",
    updates: (_updates3 = {}, _updates3[key] = {
     type: "update"
    }, _updates3)
   }), this._doc.dispatch(item._serialize(this._id, key, this._doc), oldValue ? oldValue._serialize(this._id, key) : [ {
    type: exports.OpCode.DELETE_CRDT,
    id: id
   } ], storageUpdates);
  }
 }, _proto.has = function(key) {
  return this._map.has(key);
 }, _proto.delete = function(key) {
  var item = this._map.get(key);
  if (null == item) return !1;
  if (item._detach(), this._map.delete(key), this._doc && item._id) {
   var _updates4, storageUpdates = new Map;
   storageUpdates.set(this._id, {
    node: this,
    type: "LiveMap",
    updates: (_updates4 = {}, _updates4[key] = {
     type: "delete"
    }, _updates4)
   }), this._doc.dispatch([ {
    type: exports.OpCode.DELETE_CRDT,
    id: item._id,
    opId: this._doc.generateOpId()
   } ], item._serialize(this._id, key), storageUpdates);
  }
  return !0;
 }, _proto.entries = function() {
  var _ref2, innerIterator = this._map.entries();
  return (_ref2 = {})[Symbol.iterator] = function() {
   return this;
  }, _ref2.next = function() {
   var iteratorValue = innerIterator.next();
   return iteratorValue.done ? {
    done: !0,
    value: void 0
   } : {
    value: [ iteratorValue.value[0], selfOrRegisterValue(iteratorValue.value[1]) ]
   };
  }, _ref2;
 }, _proto[_Symbol$iterator] = function() {
  return this.entries();
 }, _proto.keys = function() {
  return this._map.keys();
 }, _proto.values = function() {
  var _ref3, innerIterator = this._map.values();
  return (_ref3 = {})[Symbol.iterator] = function() {
   return this;
  }, _ref3.next = function() {
   var iteratorValue = innerIterator.next();
   return iteratorValue.done ? {
    done: !0,
    value: void 0
   } : {
    value: selfOrRegisterValue(iteratorValue.value)
   };
  }, _ref3;
 }, _proto.forEach = function(callback) {
  for (var _step7, _iterator7 = _createForOfIteratorHelperLoose(this); !(_step7 = _iterator7()).done; ) {
   var entry = _step7.value;
   callback(entry[1], entry[0], this);
  }
 }, _createClass(LiveMap, [ {
  key: "size",
  get: function() {
   return this._map.size;
  }
 } ]), LiveMap;
}(AbstractCrdt);

function creationOpToLiveStructure(op) {
 switch (op.type) {
 case exports.OpCode.CREATE_REGISTER:
  return new LiveRegister(op.data);

 case exports.OpCode.CREATE_OBJECT:
  return new LiveObject(op.data);

 case exports.OpCode.CREATE_MAP:
  return new LiveMap;

 case exports.OpCode.CREATE_LIST:
  return new LiveList;
 }
}

function deserialize(entry, parentToChildren, doc) {
 switch (entry[1].type) {
 case exports.CrdtType.OBJECT:
  return LiveObject._deserialize(entry, parentToChildren, doc);

 case exports.CrdtType.LIST:
  return LiveList._deserialize(entry, parentToChildren, doc);

 case exports.CrdtType.MAP:
  return LiveMap._deserialize(entry, parentToChildren, doc);

 case exports.CrdtType.REGISTER:
  return LiveRegister._deserialize(entry, parentToChildren, doc);

 default:
  throw new Error("Unexpected CRDT type");
 }
}

function isCrdt(obj) {
 return obj instanceof LiveObject || obj instanceof LiveMap || obj instanceof LiveList || obj instanceof LiveRegister;
}

function selfOrRegisterValue(obj) {
 return obj instanceof LiveRegister ? obj.data : obj;
}

function selfOrRegister(obj) {
 if (obj instanceof LiveObject || obj instanceof LiveMap || obj instanceof LiveList) return obj;
 if (obj instanceof LiveRegister) throw new Error("Internal error. LiveRegister should not be created from selfOrRegister");
 return new LiveRegister(obj);
}

function isPlain(value) {
 var type = typeof value;
 return "undefined" === type || null === value || "string" === type || "boolean" === type || "number" === type || Array.isArray(value) || function(value) {
  if ("object" != typeof value || null === value) return !1;
  var proto = Object.getPrototypeOf(value);
  if (null === proto) return !0;
  var baseProto = proto;
  for (;null !== Object.getPrototypeOf(baseProto); ) baseProto = Object.getPrototypeOf(baseProto);
  return proto === baseProto;
 }(value);
}

function entries(obj) {
 return Object.entries(obj);
}

var LiveObject = function(_AbstractCrdt) {
 function LiveObject(obj) {
  var _this;
  for (var key in void 0 === obj && (obj = {}), (_this = _AbstractCrdt.call(this) || this)._map = void 0, 
  _this._propToLastUpdate = void 0, _this._propToLastUpdate = new Map, obj) {
   var value = obj[key];
   value instanceof AbstractCrdt && value._setParentLink(_assertThisInitialized(_this), key);
  }
  return _this._map = new Map(Object.entries(obj)), _this;
 }
 _inheritsLoose(LiveObject, _AbstractCrdt);
 var _proto = LiveObject.prototype;
 return _proto._serialize = function(parentId, parentKey, doc, intent) {
  if (null == this._id) throw new Error("Cannot serialize item is not attached");
  var ops = [], op = {
   id: this._id,
   opId: null == doc ? void 0 : doc.generateOpId(),
   intent: intent,
   type: exports.OpCode.CREATE_OBJECT,
   parentId: parentId,
   parentKey: parentKey,
   data: {}
  };
  ops.push(op);
  for (var _step, _iterator = _createForOfIteratorHelperLoose(this._map); !(_step = _iterator()).done; ) {
   var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
   value instanceof AbstractCrdt ? ops.push.apply(ops, value._serialize(this._id, key, doc)) : op.data[key] = value;
  }
  return ops;
 }, LiveObject._deserialize = function(_ref, parentToChildren, doc) {
  var id = _ref[0], item = _ref[1];
  if (item.type !== exports.CrdtType.OBJECT) throw new Error('Tried to deserialize a record but item type is "' + item.type + '"');
  var liveObj = new LiveObject(item.data);
  return liveObj._attach(id, doc), this._deserializeChildren(liveObj, parentToChildren, doc);
 }, LiveObject._deserializeChildren = function(liveObj, parentToChildren, doc) {
  var children = parentToChildren.get(liveObj._id);
  if (null == children) return liveObj;
  for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(children); !(_step2 = _iterator2()).done; ) {
   var entry = _step2.value, crdt = entry[1];
   if (null == crdt.parentKey) throw new Error("Tried to deserialize a crdt but it does not have a parentKey and is not the root");
   var child = deserialize(entry, parentToChildren, doc);
   child._setParentLink(liveObj, crdt.parentKey), liveObj._map.set(crdt.parentKey, child);
  }
  return liveObj;
 }, _proto._attach = function(id, doc) {
  _AbstractCrdt.prototype._attach.call(this, id, doc);
  for (var _step3, _iterator3 = _createForOfIteratorHelperLoose(this._map); !(_step3 = _iterator3()).done; ) {
   var _step3$value = _step3.value;
   _step3$value[0];
   var value = _step3$value[1];
   value instanceof AbstractCrdt && value._attach(doc.generateId(), doc);
  }
 }, _proto._attachChild = function(op, isLocal) {
  var _updates;
  if (null == this._doc) throw new Error("Can't attach child if doc is not present");
  var id = op.id, parentKey = op.parentKey, opId = op.opId, key = parentKey, child = creationOpToLiveStructure(op);
  if (void 0 !== this._doc.getItem(id)) return this._propToLastUpdate.get(key) === opId && this._propToLastUpdate.delete(key), 
  {
   modified: !1
  };
  if (isLocal) this._propToLastUpdate.set(key, opId); else if (void 0 !== this._propToLastUpdate.get(key)) return this._propToLastUpdate.get(key) === opId ? (this._propToLastUpdate.delete(key), 
  {
   modified: !1
  }) : {
   modified: !1
  };
  var reverse, previousValue = this._map.get(key);
  if (isCrdt(previousValue)) reverse = previousValue._serialize(this._id, key), previousValue._detach(); else if (void 0 === previousValue) reverse = [ {
   type: exports.OpCode.DELETE_OBJECT_KEY,
   id: this._id,
   key: key
  } ]; else {
   var _data;
   reverse = [ {
    type: exports.OpCode.UPDATE_OBJECT,
    id: this._id,
    data: (_data = {}, _data[key] = previousValue, _data)
   } ];
  }
  return this._map.set(key, child), child._setParentLink(this, key), child._attach(id, this._doc), 
  {
   reverse: reverse,
   modified: {
    node: this,
    type: "LiveObject",
    updates: (_updates = {}, _updates[key] = {
     type: "update"
    }, _updates)
   }
  };
 }, _proto._detachChild = function(child) {
  if (child) {
   for (var _updates2, _step4, reverse = child._serialize(this._id, child._parentKey, this._doc), _iterator4 = _createForOfIteratorHelperLoose(this._map); !(_step4 = _iterator4()).done; ) {
    var _step4$value = _step4.value, key = _step4$value[0];
    _step4$value[1] === child && this._map.delete(key);
   }
   return child._detach(), {
    modified: {
     node: this,
     type: "LiveObject",
     updates: (_updates2 = {}, _updates2[child._parentKey] = {
      type: "delete"
     }, _updates2)
    },
    reverse: reverse
   };
  }
  return {
   modified: !1
  };
 }, _proto._detachChildren = function() {
  for (var _step5, _iterator5 = _createForOfIteratorHelperLoose(this._map); !(_step5 = _iterator5()).done; ) {
   var _step5$value = _step5.value, key = _step5$value[0], value = _step5$value[1];
   this._map.delete(key), value._detach();
  }
 }, _proto._detach = function() {
  _AbstractCrdt.prototype._detach.call(this);
  for (var _step6, _iterator6 = _createForOfIteratorHelperLoose(this._map.values()); !(_step6 = _iterator6()).done; ) {
   var value = _step6.value;
   isCrdt(value) && value._detach();
  }
 }, _proto._apply = function(op, isLocal) {
  return op.type === exports.OpCode.UPDATE_OBJECT ? this._applyUpdate(op, isLocal) : op.type === exports.OpCode.DELETE_OBJECT_KEY ? this._applyDeleteObjectKey(op) : _AbstractCrdt.prototype._apply.call(this, op, isLocal);
 }, _proto._toSerializedCrdt = function() {
  for (var _this$_parent, _step7, data = {}, _iterator7 = _createForOfIteratorHelperLoose(this._map); !(_step7 = _iterator7()).done; ) {
   var _step7$value = _step7.value, key = _step7$value[0], value = _step7$value[1];
   value instanceof AbstractCrdt == !1 && (data[key] = value);
  }
  return {
   type: exports.CrdtType.OBJECT,
   parentId: null == (_this$_parent = this._parent) ? void 0 : _this$_parent._id,
   parentKey: this._parentKey,
   data: data
  };
 }, _proto._applyUpdate = function(op, isLocal) {
  var isModified = !1, reverse = [], reverseUpdate = {
   type: exports.OpCode.UPDATE_OBJECT,
   id: this._id,
   data: {}
  };
  for (var key in reverse.push(reverseUpdate), op.data) {
   var oldValue = this._map.get(key);
   oldValue instanceof AbstractCrdt ? (reverse.push.apply(reverse, oldValue._serialize(this._id, key)), 
   oldValue._detach()) : void 0 !== oldValue ? reverseUpdate.data[key] = oldValue : void 0 === oldValue && reverse.push({
    type: exports.OpCode.DELETE_OBJECT_KEY,
    id: this._id,
    key: key
   });
  }
  var updateDelta = {};
  for (var _key2 in op.data) {
   if (isLocal) this._propToLastUpdate.set(_key2, op.opId); else {
    if (null != this._propToLastUpdate.get(_key2)) {
     if (this._propToLastUpdate.get(_key2) === op.opId) {
      this._propToLastUpdate.delete(_key2);
      continue;
     }
     continue;
    }
    isModified = !0;
   }
   var _oldValue = this._map.get(_key2);
   isCrdt(_oldValue) && _oldValue._detach(), isModified = !0, updateDelta[_key2] = {
    type: "update"
   }, this._map.set(_key2, op.data[_key2]);
  }
  return 0 !== Object.keys(reverseUpdate.data).length && reverse.unshift(reverseUpdate), 
  isModified ? {
   modified: {
    node: this,
    type: "LiveObject",
    updates: updateDelta
   },
   reverse: reverse
  } : {
   modified: !1
  };
 }, _proto._applyDeleteObjectKey = function(op) {
  var _updates3, key = op.key;
  if (!1 === this._map.has(key)) return {
   modified: !1
  };
  if (void 0 !== this._propToLastUpdate.get(key)) return {
   modified: !1
  };
  var oldValue = this._map.get(key), reverse = [];
  if (isCrdt(oldValue)) reverse = oldValue._serialize(this._id, op.key), oldValue._detach(); else if (void 0 !== oldValue) {
   var _data2;
   reverse = [ {
    type: exports.OpCode.UPDATE_OBJECT,
    id: this._id,
    data: (_data2 = {}, _data2[key] = oldValue, _data2)
   } ];
  }
  return this._map.delete(key), {
   modified: {
    node: this,
    type: "LiveObject",
    updates: (_updates3 = {}, _updates3[op.key] = {
     type: "delete"
    }, _updates3)
   },
   reverse: reverse
  };
 }, _proto.toObject = function() {
  return function(iterable) {
   for (var _step3, obj = {}, _iterator3 = _createForOfIteratorHelperLoose(iterable); !(_step3 = _iterator3()).done; ) {
    var _step3$value = _step3.value, _key4 = _step3$value[0], val = _step3$value[1];
    obj[_key4] = val;
   }
   return obj;
  }(this._map);
 }, _proto.set = function(key, value) {
  var _this$update;
  this.update(((_this$update = {})[key] = value, _this$update));
 }, _proto.get = function(key) {
  return this._map.get(key);
 }, _proto.delete = function(key) {
  var _updates4, keyAsString = key, oldValue = this._map.get(keyAsString);
  if (void 0 !== oldValue) {
   if (null == this._doc || null == this._id) return oldValue instanceof AbstractCrdt && oldValue._detach(), 
   void this._map.delete(keyAsString);
   var reverse, _data3;
   if (oldValue instanceof AbstractCrdt) oldValue._detach(), reverse = oldValue._serialize(this._id, keyAsString); else reverse = [ {
    type: exports.OpCode.UPDATE_OBJECT,
    data: (_data3 = {}, _data3[keyAsString] = oldValue, _data3),
    id: this._id
   } ];
   this._map.delete(keyAsString);
   var storageUpdates = new Map;
   storageUpdates.set(this._id, {
    node: this,
    type: "LiveObject",
    updates: (_updates4 = {}, _updates4[key] = {
     type: "delete"
    }, _updates4)
   }), this._doc.dispatch([ {
    type: exports.OpCode.DELETE_OBJECT_KEY,
    key: keyAsString,
    id: this._id,
    opId: this._doc.generateOpId()
   } ], reverse, storageUpdates);
  }
 }, _proto.update = function(overrides) {
  var _this2 = this;
  if (null != this._doc && null != this._id) {
   var ops = [], reverseOps = [], opId = this._doc.generateOpId(), updatedProps = {}, reverseUpdateOp = {
    id: this._id,
    type: exports.OpCode.UPDATE_OBJECT,
    data: {}
   }, updateDelta = {};
   for (var _key3 in overrides) {
    var _oldValue2 = this._map.get(_key3);
    _oldValue2 instanceof AbstractCrdt ? (reverseOps.push.apply(reverseOps, _oldValue2._serialize(this._id, _key3)), 
    _oldValue2._detach()) : void 0 === _oldValue2 ? reverseOps.push({
     type: exports.OpCode.DELETE_OBJECT_KEY,
     id: this._id,
     key: _key3
    }) : reverseUpdateOp.data[_key3] = _oldValue2;
    var _newValue = overrides[_key3];
    if (_newValue instanceof AbstractCrdt) {
     _newValue._setParentLink(this, _key3), _newValue._attach(this._doc.generateId(), this._doc);
     var newAttachChildOps = _newValue._serialize(this._id, _key3, this._doc), createCrdtOp = newAttachChildOps.find((function(op) {
      return op.parentId === _this2._id;
     }));
     createCrdtOp && this._propToLastUpdate.set(_key3, createCrdtOp.opId), ops.push.apply(ops, newAttachChildOps);
    } else updatedProps[_key3] = _newValue, this._propToLastUpdate.set(_key3, opId);
    this._map.set(_key3, _newValue), updateDelta[_key3] = {
     type: "update"
    };
   }
   0 !== Object.keys(reverseUpdateOp.data).length && reverseOps.unshift(reverseUpdateOp), 
   0 !== Object.keys(updatedProps).length && ops.unshift({
    opId: opId,
    id: this._id,
    type: exports.OpCode.UPDATE_OBJECT,
    data: updatedProps
   });
   var storageUpdates = new Map;
   storageUpdates.set(this._id, {
    node: this,
    type: "LiveObject",
    updates: updateDelta
   }), this._doc.dispatch(ops, reverseOps, storageUpdates);
  } else for (var key in overrides) {
   var oldValue = this._map.get(key);
   oldValue instanceof AbstractCrdt && oldValue._detach();
   var newValue = overrides[key];
   newValue instanceof AbstractCrdt && newValue._setParentLink(this, key), this._map.set(key, newValue);
  }
 }, LiveObject;
}(AbstractCrdt);

exports.AbstractCrdt = AbstractCrdt, exports.LiveList = LiveList, exports.LiveMap = LiveMap, 
exports.LiveObject = LiveObject, exports.LiveRegister = LiveRegister, exports._createForOfIteratorHelperLoose = _createForOfIteratorHelperLoose, 
exports._extends = _extends, exports._inheritsLoose = _inheritsLoose, exports._objectWithoutPropertiesLoose = function(source, excluded) {
 if (null == source) return {};
 var key, i, target = {}, sourceKeys = Object.keys(source);
 for (i = 0; i < sourceKeys.length; i++) key = sourceKeys[i], excluded.indexOf(key) >= 0 || (target[key] = source[key]);
 return target;
}, exports._wrapNativeSuper = _wrapNativeSuper, exports.compact = function(items) {
 return items.filter((function(item) {
  return null != item;
 }));
}, exports.comparePosition = comparePosition, exports.deprecate = deprecate, exports.deprecateIf = deprecateIf, 
exports.errorIf = function(condition, message) {
 "production" !== process.env.NODE_ENV && condition && throwUsageError(message);
}, exports.findNonSerializableValue = function findNonSerializableValue(value, path) {
 if (void 0 === path && (path = ""), !isPlain) return {
  path: path || "root",
  value: value
 };
 if ("object" != typeof value || null === value) return !1;
 for (var _i = 0, _Object$entries = Object.entries(value); _i < _Object$entries.length; _i++) {
  var _Object$entries$_i = _Object$entries[_i], _key3 = _Object$entries$_i[0], nestedValue = _Object$entries$_i[1], nestedPath = path ? path + "." + _key3 : _key3;
  if (!isPlain(nestedValue)) return {
   path: nestedPath,
   value: nestedValue
  };
  if ("object" == typeof nestedValue) {
   var nonSerializableNestedValue = findNonSerializableValue(nestedValue, nestedPath);
   if (nonSerializableNestedValue) return nonSerializableNestedValue;
  }
 }
 return !1;
}, exports.getTreesDiffOperations = function(currentItems, newItems) {
 var ops = [];
 return currentItems.forEach((function(_, id) {
  newItems.get(id) || ops.push({
   type: exports.OpCode.DELETE_CRDT,
   id: id
  });
 })), newItems.forEach((function(crdt, id) {
  var currentCrdt = currentItems.get(id);
  if (currentCrdt) crdt.type === exports.CrdtType.OBJECT && JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data) && ops.push({
   type: exports.OpCode.UPDATE_OBJECT,
   id: id,
   data: crdt.data
  }), crdt.parentKey !== currentCrdt.parentKey && ops.push({
   type: exports.OpCode.SET_PARENT_KEY,
   id: id,
   parentKey: crdt.parentKey
  }); else switch (crdt.type) {
  case exports.CrdtType.REGISTER:
   ops.push({
    type: exports.OpCode.CREATE_REGISTER,
    id: id,
    parentId: crdt.parentId,
    parentKey: crdt.parentKey,
    data: crdt.data
   });
   break;

  case exports.CrdtType.LIST:
   ops.push({
    type: exports.OpCode.CREATE_LIST,
    id: id,
    parentId: crdt.parentId,
    parentKey: crdt.parentKey
   });
   break;

  case exports.CrdtType.OBJECT:
   ops.push({
    type: exports.OpCode.CREATE_OBJECT,
    id: id,
    parentId: crdt.parentId,
    parentKey: crdt.parentKey,
    data: crdt.data
   });
   break;

  case exports.CrdtType.MAP:
   ops.push({
    type: exports.OpCode.CREATE_MAP,
    id: id,
    parentId: crdt.parentId,
    parentKey: crdt.parentKey
   });
  }
 })), ops;
}, exports.isJsonArray = isJsonArray, exports.isJsonObject = isJsonObject, exports.isSameNodeOrChildOf = function isSameNodeOrChildOf(node, parent) {
 return node === parent || !!node._parent && isSameNodeOrChildOf(node._parent, parent);
}, exports.isTokenValid = function(token) {
 var tokenParts = token.split(".");
 if (3 !== tokenParts.length) return !1;
 var data = parseJson(atob(tokenParts[1]));
 return !(void 0 === data || !isJsonObject(data) || "number" != typeof data.exp) && !(Date.now() / 1e3 > data.exp - 300);
}, exports.makePosition = makePosition, exports.mergeStorageUpdates = function(first, second) {
 return first ? "LiveObject" === first.type && "LiveObject" === second.type ? function(first, second) {
  for (var _step, updates = first.updates, _iterator = _createForOfIteratorHelperLoose(entries(second.updates)); !(_step = _iterator()).done; ) {
   var _step$value = _step.value, _key = _step$value[0], value = _step$value[1];
   updates[_key] = value;
  }
  return _extends({}, second, {
   updates: updates
  });
 }(first, second) : "LiveMap" === first.type && "LiveMap" === second.type ? function(first, second) {
  for (var _step2, updates = first.updates, _iterator2 = _createForOfIteratorHelperLoose(entries(second.updates)); !(_step2 = _iterator2()).done; ) {
   var _step2$value = _step2.value, _key2 = _step2$value[0], value = _step2$value[1];
   updates[_key2] = value;
  }
  return _extends({}, second, {
   updates: updates
  });
 }(first, second) : "LiveList" === first.type && "LiveList" === second.type ? function(first, second) {
  return _extends({}, second, {
   updates: first.updates.concat(second.updates)
  });
 }(first, second) : second : second;
}, exports.parseJson = parseJson, exports.remove = function(array, item) {
 for (var i = 0; i < array.length; i++) if (array[i] === item) {
  array.splice(i, 1);
  break;
 }
}, exports.throwUsageError = throwUsageError;
