"use strict";

Object.defineProperty(exports, "__esModule", {
 value: !0
});

var LiveObject = require("./shared.js"), _excluded = [ "_hasReceivedInitialPresence" ], BACKOFF_RETRY_DELAYS = [ 250, 500, 1e3, 2e3, 4e3, 8e3, 1e4 ], BACKOFF_RETRY_DELAYS_SLOW = [ 2e3, 3e4, 6e4, 3e5 ];

function isValidRoomEventType(value) {
 return "my-presence" === value || "others" === value || "event" === value || "error" === value || "connection" === value;
}

function makeOthers(userMap) {
 var _ref, users = Object.values(userMap).map((function(user) {
  return user._hasReceivedInitialPresence, LiveObject._objectWithoutPropertiesLoose(user, _excluded);
 }));
 return (_ref = {
  get count() {
   return users.length;
  }
 })[Symbol.iterator] = function() {
  return users[Symbol.iterator]();
 }, _ref.map = function(callback) {
  return users.map(callback);
 }, _ref.toArray = function() {
  return users;
 }, _ref;
}

function makeStateMachine(state, context, mockedEffects) {
 var effects = mockedEffects || {
  authenticate: function(auth, createWebSocket) {
   var token = state.token;
   if (!token || !LiveObject.isTokenValid(token)) return auth(context.roomId).then((function(_ref2) {
    var token = _ref2.token;
    "authenticating" === state.connection.state && (authenticationSuccess(parseToken(token), createWebSocket(token)), 
    state.token = token);
   })).catch((function(er) {
    return function(error) {
     "production" !== process.env.NODE_ENV && console.error("Call to authentication endpoint failed", error);
     state.token = null, updateConnection({
      state: "unavailable"
     }), state.numberOfRetry++, state.timeoutHandles.reconnect = effects.scheduleReconnect(getRetryDelay());
    }(er);
   }));
   authenticationSuccess(parseToken(token), createWebSocket(token));
  },
  send: function(messageOrMessages) {
   if (null == state.socket) throw new Error("Can't send message if socket is null");
   state.socket.send(JSON.stringify(messageOrMessages));
  },
  delayFlush: function(delay) {
   return setTimeout(tryFlushing, delay);
  },
  startHeartbeatInterval: function() {
   return setInterval(heartbeat, 3e4);
  },
  schedulePongTimeout: function() {
   return setTimeout(pongTimeout, 2e3);
  },
  scheduleReconnect: function(delay) {
   return setTimeout(connect, delay);
  }
 };
 function genericSubscribe(callback) {
  return state.listeners.storage.push(callback), function() {
   return LiveObject.remove(state.listeners.storage, callback);
  };
 }
 function createOrUpdateRootFromMessage(message) {
  if (0 === message.items.length) throw new Error("Internal error: cannot load storage without items");
  var items, _buildRootAndParentTo, root, parentToChildren;
  for (var _key in state.root ? function(items) {
   if (!state.root) return;
   var currentItems = new Map;
   state.items.forEach((function(liveCrdt, id) {
    currentItems.set(id, liveCrdt._toSerializedCrdt());
   })), notify(apply(LiveObject.getTreesDiffOperations(currentItems, new Map(items)), !1).updates);
  }(message.items) : state.root = (items = message.items, _buildRootAndParentTo = function(items) {
   for (var _step2, parentToChildren = new Map, root = null, _iterator2 = LiveObject._createForOfIteratorHelperLoose(items); !(_step2 = _iterator2()).done; ) {
    var tuple = _step2.value, parentId = tuple[1].parentId;
    if (null == parentId) root = tuple; else {
     var children = parentToChildren.get(parentId);
     null != children ? children.push(tuple) : parentToChildren.set(parentId, [ tuple ]);
    }
   }
   if (null == root) throw new Error("Root can't be null");
   return [ root, parentToChildren ];
  }(items), root = _buildRootAndParentTo[0], parentToChildren = _buildRootAndParentTo[1], 
  LiveObject.LiveObject._deserialize(root, parentToChildren, {
   getItem: getItem,
   addItem: addItem,
   deleteItem: deleteItem,
   generateId: generateId,
   generateOpId: generateOpId,
   dispatch: storageDispatch,
   roomId: context.roomId
  })), state.defaultStorageRoot) null == state.root.get(_key) && state.root.set(_key, state.defaultStorageRoot[_key]);
 }
 function addItem(id, item) {
  state.items.set(id, item);
 }
 function deleteItem(id) {
  state.items.delete(id);
 }
 function getItem(id) {
  return state.items.get(id);
 }
 function addToUndoStack(historyItem) {
  var _state$pausedHistory;
  (state.undoStack.length >= 50 && state.undoStack.shift(), state.isHistoryPaused) ? (_state$pausedHistory = state.pausedHistory).unshift.apply(_state$pausedHistory, historyItem) : state.undoStack.push(historyItem);
 }
 function storageDispatch(ops, reverse, storageUpdates) {
  var _state$batch$ops, _state$batch$reverseO;
  state.isBatching ? ((_state$batch$ops = state.batch.ops).push.apply(_state$batch$ops, ops), 
  storageUpdates.forEach((function(value, key) {
   state.batch.updates.storageUpdates.set(key, LiveObject.mergeStorageUpdates(state.batch.updates.storageUpdates.get(key), value));
  })), (_state$batch$reverseO = state.batch.reverseOps).push.apply(_state$batch$reverseO, reverse)) : (addToUndoStack(reverse), 
  state.redoStack = [], dispatch(ops), notify({
   storageUpdates: storageUpdates
  }));
 }
 function notify(_ref3) {
  var _ref3$storageUpdates = _ref3.storageUpdates, storageUpdates = void 0 === _ref3$storageUpdates ? new Map : _ref3$storageUpdates, _ref3$presence = _ref3.presence, presence = void 0 !== _ref3$presence && _ref3$presence, _ref3$others = _ref3.others, otherEvents = void 0 === _ref3$others ? [] : _ref3$others;
  if (otherEvents.length > 0) {
   state.others = makeOthers(state.users);
   for (var _step3, _iterator3 = LiveObject._createForOfIteratorHelperLoose(otherEvents); !(_step3 = _iterator3()).done; ) for (var _step4, _event = _step3.value, _iterator4 = LiveObject._createForOfIteratorHelperLoose(state.listeners.others); !(_step4 = _iterator4()).done; ) {
    (0, _step4.value)(state.others, _event);
   }
  }
  if (presence) for (var _step5, _iterator5 = LiveObject._createForOfIteratorHelperLoose(state.listeners["my-presence"]); !(_step5 = _iterator5()).done; ) {
   (0, _step5.value)(state.me);
  }
  if (storageUpdates.size > 0) for (var _step6, _iterator6 = LiveObject._createForOfIteratorHelperLoose(state.listeners.storage); !(_step6 = _iterator6()).done; ) {
   (0, _step6.value)(Array.from(storageUpdates.values()));
  }
 }
 function getConnectionId() {
  if ("open" === state.connection.state || "connecting" === state.connection.state) return state.connection.id;
  if (null !== state.lastConnectionId) return state.lastConnectionId;
  throw new Error("Internal. Tried to get connection id but connection was never open");
 }
 function generateId() {
  return getConnectionId() + ":" + state.clock++;
 }
 function generateOpId() {
  return getConnectionId() + ":" + state.opClock++;
 }
 function apply(item, isLocal) {
  for (var _step7, result = {
   reverse: [],
   updates: {
    storageUpdates: new Map,
    presence: !1
   }
  }, createdNodeIds = new Set, _iterator7 = LiveObject._createForOfIteratorHelperLoose(item); !(_step7 = _iterator7()).done; ) {
   var op = _step7.value;
   if ("presence" === op.type) {
    var reverse = {
     type: "presence",
     data: {}
    };
    for (var _key2 in op.data) reverse.data[_key2] = state.me[_key2];
    if (state.me = LiveObject._extends({}, state.me, op.data), null == state.buffer.presence) state.buffer.presence = op.data; else for (var _key3 in op.data) state.buffer.presence[_key3] = op.data[_key3];
    result.reverse.unshift(reverse), result.updates.presence = !0;
   } else {
    isLocal && !op.opId && (op.opId = generateOpId());
    var applyOpResult = applyOp(op, isLocal);
    if (applyOpResult.modified) {
     var _applyOpResult$modifi, _result$reverse, parentId = null == (_applyOpResult$modifi = applyOpResult.modified.node._parent) ? void 0 : _applyOpResult$modifi._id;
     if (!createdNodeIds.has(parentId)) result.updates.storageUpdates.set(applyOpResult.modified.node._id, LiveObject.mergeStorageUpdates(result.updates.storageUpdates.get(applyOpResult.modified.node._id), applyOpResult.modified)), 
     (_result$reverse = result.reverse).unshift.apply(_result$reverse, applyOpResult.reverse);
     op.type !== LiveObject.OpCode.CREATE_LIST && op.type !== LiveObject.OpCode.CREATE_MAP && op.type !== LiveObject.OpCode.CREATE_OBJECT || createdNodeIds.add(applyOpResult.modified.node._id);
    }
   }
  }
  return result;
 }
 function applyOp(op, isLocal) {
  switch (op.opId && state.offlineOperations.delete(op.opId), op.type) {
  case LiveObject.OpCode.DELETE_OBJECT_KEY:
  case LiveObject.OpCode.UPDATE_OBJECT:
  case LiveObject.OpCode.DELETE_CRDT:
   var item = state.items.get(op.id);
   return null == item ? {
    modified: !1
   } : item._apply(op, isLocal);

  case LiveObject.OpCode.SET_PARENT_KEY:
   var _item = state.items.get(op.id);
   if (null == _item) return {
    modified: !1
   };
   if (_item._parent instanceof LiveObject.LiveList) {
    var previousKey = _item._parentKey;
    return previousKey === op.parentKey ? {
     modified: !1
    } : _item._parent._setChildKey(op.parentKey, _item, previousKey);
   }
   return {
    modified: !1
   };

  case LiveObject.OpCode.CREATE_OBJECT:
  case LiveObject.OpCode.CREATE_LIST:
  case LiveObject.OpCode.CREATE_MAP:
  case LiveObject.OpCode.CREATE_REGISTER:
   var parent = state.items.get(op.parentId);
   return null == parent ? {
    modified: !1
   } : parent._attachChild(op, isLocal);
  }
 }
 function connect() {
  if ("closed" !== state.connection.state && "unavailable" !== state.connection.state) return null;
  var auth = function(authentication, fetchPolyfill) {
   if ("public" === authentication.type) {
    if ("undefined" == typeof window && null == fetchPolyfill) throw new Error("To use Liveblocks client in a non-dom environment with a publicApiKey, you need to provide a fetch polyfill.");
    return function(room) {
     return fetchAuthEndpoint(fetchPolyfill || fetch, authentication.url, {
      room: room,
      publicApiKey: authentication.publicApiKey
     });
    };
   }
   if ("private" === authentication.type) {
    if ("undefined" == typeof window && null == fetchPolyfill) throw new Error("To use Liveblocks client in a non-dom environment with a url as auth endpoint, you need to provide a fetch polyfill.");
    return function(room) {
     return fetchAuthEndpoint(fetchPolyfill || fetch, authentication.url, {
      room: room
     });
    };
   }
   if ("custom" === authentication.type) return authentication.callback;
   throw new Error("Internal error. Unexpected authentication type");
  }(context.authentication, context.fetchPolyfill), createWebSocket = function(liveblocksServer, WebSocketPolyfill) {
   if ("undefined" == typeof window && null == WebSocketPolyfill) throw new Error("To use Liveblocks client in a non-dom environment, you need to provide a WebSocket polyfill.");
   var ws = WebSocketPolyfill || WebSocket;
   return function(token) {
    return new ws(liveblocksServer + "/?token=" + token);
   };
  }(context.liveblocksServer, context.WebSocketPolyfill);
  updateConnection({
   state: "authenticating"
  }), effects.authenticate(auth, createWebSocket);
 }
 function authenticationSuccess(token, socket) {
  var connectionId, count;
  socket.addEventListener("message", onMessage), socket.addEventListener("open", onOpen), 
  socket.addEventListener("close", onClose), socket.addEventListener("error", onError), 
  updateConnection({
   state: "connecting",
   id: token.actor,
   userInfo: token.info,
   userId: token.id
  }), state.idFactory = (connectionId = token.actor, count = 0, function() {
   return connectionId + ":" + count++;
  }), state.socket = socket;
 }
 function onUpdatePresenceMessage(message) {
  var user = state.users[message.actor];
  if (void 0 !== message.targetActor || null == user || user._hasReceivedInitialPresence) return state.users[message.actor] = null == user ? {
   connectionId: message.actor,
   presence: message.data,
   _hasReceivedInitialPresence: !0
  } : {
   id: user.id,
   info: user.info,
   connectionId: message.actor,
   presence: LiveObject._extends({}, user.presence, message.data),
   _hasReceivedInitialPresence: !0
  }, {
   type: "update",
   updates: message.data,
   user: state.users[message.actor]
  };
 }
 function onUserLeftMessage(message) {
  var userLeftMessage = message, user = state.users[userLeftMessage.actor];
  return user ? (delete state.users[userLeftMessage.actor], {
   type: "leave",
   user: user
  }) : null;
 }
 function onRoomStateMessage(message) {
  var newUsers = {};
  for (var _key5 in message.users) {
   var _connectionId = Number.parseInt(_key5), user = message.users[_key5];
   newUsers[_connectionId] = {
    connectionId: _connectionId,
    info: user.info,
    id: user.id
   };
  }
  return state.users = newUsers, {
   type: "reset"
  };
 }
 function onEvent(message) {
  for (var _step8, _iterator8 = LiveObject._createForOfIteratorHelperLoose(state.listeners.event); !(_step8 = _iterator8()).done; ) {
   (0, _step8.value)({
    connectionId: message.actor,
    event: message.event
   });
  }
 }
 function onUserJoinedMessage(message) {
  return state.users[message.actor] = {
   connectionId: message.actor,
   info: message.info,
   id: message.id,
   _hasReceivedInitialPresence: !0
  }, state.me && (state.buffer.messages.push({
   type: LiveObject.ClientMsgCode.UPDATE_PRESENCE,
   data: state.me,
   targetActor: message.actor
  }), tryFlushing()), {
   type: "enter",
   user: state.users[message.actor]
  };
 }
 function parseServerMessage(data) {
  return LiveObject.isJsonObject(data) ? data : null;
 }
 function onMessage(event) {
  if ("pong" !== event.data) {
   var text, data, messages = (text = event.data, void 0 === (data = LiveObject.parseJson(text)) ? null : LiveObject.isJsonArray(data) ? LiveObject.compact(data.map((function(item) {
    return parseServerMessage(item);
   }))) : LiveObject.compact([ parseServerMessage(data) ]));
   if (null !== messages && 0 !== messages.length) {
    for (var _step9, updates = {
     storageUpdates: new Map,
     others: []
    }, _iterator9 = LiveObject._createForOfIteratorHelperLoose(messages); !(_step9 = _iterator9()).done; ) {
     var message = _step9.value;
     switch (message.type) {
     case LiveObject.ServerMsgCode.USER_JOINED:
      updates.others.push(onUserJoinedMessage(message));
      break;

     case LiveObject.ServerMsgCode.UPDATE_PRESENCE:
      var othersPresenceUpdate = onUpdatePresenceMessage(message);
      othersPresenceUpdate && updates.others.push(othersPresenceUpdate);
      break;

     case LiveObject.ServerMsgCode.BROADCASTED_EVENT:
      onEvent(message);
      break;

     case LiveObject.ServerMsgCode.USER_LEFT:
      var _event2 = onUserLeftMessage(message);
      _event2 && updates.others.push(_event2);
      break;

     case LiveObject.ServerMsgCode.ROOM_STATE:
      updates.others.push(onRoomStateMessage(message));
      break;

     case LiveObject.ServerMsgCode.INITIAL_STORAGE_STATE:
      var offlineOps = new Map(state.offlineOperations);
      createOrUpdateRootFromMessage(message), applyAndSendOfflineOps(offlineOps), null == _getInitialStateResolver || _getInitialStateResolver();
      break;

     case LiveObject.ServerMsgCode.UPDATE_STORAGE:
      apply(message.ops, !1).updates.storageUpdates.forEach((function(value, key) {
       updates.storageUpdates.set(key, LiveObject.mergeStorageUpdates(updates.storageUpdates.get(key), value));
      }));
     }
    }
    notify(updates);
   }
  } else clearTimeout(state.timeoutHandles.pongTimeout);
 }
 function onClose(event) {
  if (state.socket = null, clearTimeout(state.timeoutHandles.pongTimeout), clearInterval(state.intervalHandles.heartbeat), 
  state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush), clearTimeout(state.timeoutHandles.reconnect), 
  state.users = {}, notify({
   others: [ {
    type: "reset"
   } ]
  }), event.code >= 4e3 && event.code <= 4100) {
   updateConnection({
    state: "failed"
   });
   for (var _step10, error = new LiveblocksError(event.reason, event.code), _iterator10 = LiveObject._createForOfIteratorHelperLoose(state.listeners.error); !(_step10 = _iterator10()).done; ) {
    (0, _step10.value)(error);
   }
   var _delay = getRetryDelay(!0);
   state.numberOfRetry++, "production" !== process.env.NODE_ENV && console.error("Connection to Liveblocks websocket server closed. Reason: " + error.message + " (code: " + error.code + "). Retrying in " + _delay + "ms."), 
   updateConnection({
    state: "unavailable"
   }), state.timeoutHandles.reconnect = effects.scheduleReconnect(_delay);
  } else if (event.code === LiveObject.WebsocketCloseCodes.CLOSE_WITHOUT_RETRY) updateConnection({
   state: "closed"
  }); else {
   var _delay2 = getRetryDelay();
   state.numberOfRetry++, "production" !== process.env.NODE_ENV && console.warn("Connection to Liveblocks websocket server closed (code: " + event.code + "). Retrying in " + _delay2 + "ms."), 
   updateConnection({
    state: "unavailable"
   }), state.timeoutHandles.reconnect = effects.scheduleReconnect(_delay2);
  }
 }
 function updateConnection(connection) {
  state.connection = connection;
  for (var _step11, _iterator11 = LiveObject._createForOfIteratorHelperLoose(state.listeners.connection); !(_step11 = _iterator11()).done; ) {
   (0, _step11.value)(connection.state);
  }
 }
 function getRetryDelay(slow) {
  return void 0 === slow && (slow = !1), slow ? BACKOFF_RETRY_DELAYS_SLOW[state.numberOfRetry < BACKOFF_RETRY_DELAYS_SLOW.length ? state.numberOfRetry : BACKOFF_RETRY_DELAYS_SLOW.length - 1] : BACKOFF_RETRY_DELAYS[state.numberOfRetry < BACKOFF_RETRY_DELAYS.length ? state.numberOfRetry : BACKOFF_RETRY_DELAYS.length - 1];
 }
 function onError() {}
 function onOpen() {
  clearInterval(state.intervalHandles.heartbeat), state.intervalHandles.heartbeat = effects.startHeartbeatInterval(), 
  "connecting" === state.connection.state && (updateConnection(LiveObject._extends({}, state.connection, {
   state: "open"
  })), state.numberOfRetry = 0, void 0 !== state.lastConnectionId && (state.buffer.presence = state.me, 
  tryFlushing()), state.lastConnectionId = state.connection.id, state.root && state.buffer.messages.push({
   type: LiveObject.ClientMsgCode.FETCH_STORAGE
  }), tryFlushing());
 }
 function heartbeat() {
  null != state.socket && (clearTimeout(state.timeoutHandles.pongTimeout), state.timeoutHandles.pongTimeout = effects.schedulePongTimeout(), 
  state.socket.readyState === state.socket.OPEN && state.socket.send("ping"));
 }
 function pongTimeout() {
  reconnect();
 }
 function reconnect() {
  state.socket && (state.socket.removeEventListener("open", onOpen), state.socket.removeEventListener("message", onMessage), 
  state.socket.removeEventListener("close", onClose), state.socket.removeEventListener("error", onError), 
  state.socket.close(), state.socket = null), updateConnection({
   state: "unavailable"
  }), clearTimeout(state.timeoutHandles.pongTimeout), state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush), 
  clearTimeout(state.timeoutHandles.reconnect), clearInterval(state.intervalHandles.heartbeat), 
  connect();
 }
 function applyAndSendOfflineOps(offlineOps) {
  if (0 !== offlineOps.size) {
   var messages = [], ops = Array.from(offlineOps.values()), result = apply(ops, !0);
   messages.push({
    type: LiveObject.ClientMsgCode.UPDATE_STORAGE,
    ops: ops
   }), notify(result.updates), effects.send(messages);
  }
 }
 function tryFlushing() {
  var storageOps = state.buffer.storageOperations;
  if (storageOps.length > 0 && storageOps.forEach((function(op) {
   state.offlineOperations.set(op.opId, op);
  })), null != state.socket && state.socket.readyState === state.socket.OPEN) {
   var now = Date.now();
   if (now - state.lastFlushTime > context.throttleDelay) {
    var _messages = function(state) {
     var messages = [];
     state.buffer.presence && messages.push({
      type: LiveObject.ClientMsgCode.UPDATE_PRESENCE,
      data: state.buffer.presence
     });
     for (var _step12, _iterator12 = LiveObject._createForOfIteratorHelperLoose(state.buffer.messages); !(_step12 = _iterator12()).done; ) {
      var _event3 = _step12.value;
      messages.push(_event3);
     }
     state.buffer.storageOperations.length > 0 && messages.push({
      type: LiveObject.ClientMsgCode.UPDATE_STORAGE,
      ops: state.buffer.storageOperations
     });
     return messages;
    }(state);
    if (0 === _messages.length) return;
    effects.send(_messages), state.buffer = {
     messages: [],
     storageOperations: [],
     presence: null
    }, state.lastFlushTime = now;
   } else null != state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush), 
   state.timeoutHandles.flush = effects.delayFlush(context.throttleDelay - (now - state.lastFlushTime));
  } else state.buffer.storageOperations = [];
 }
 function getPresence() {
  return state.me;
 }
 function dispatch(ops) {
  var _state$buffer$storage;
  (_state$buffer$storage = state.buffer.storageOperations).push.apply(_state$buffer$storage, ops), 
  tryFlushing();
 }
 var _getInitialStatePromise = null, _getInitialStateResolver = null;
 return {
  onClose: onClose,
  onMessage: onMessage,
  authenticationSuccess: authenticationSuccess,
  heartbeat: heartbeat,
  onNavigatorOnline: function() {
   "unavailable" === state.connection.state && reconnect();
  },
  simulateSocketClose: function() {
   state.socket && state.socket.close();
  },
  simulateSendCloseEvent: function(event) {
   state.socket && onClose(event);
  },
  onVisibilityChange: function(visibilityState) {
   "visible" === visibilityState && "open" === state.connection.state && heartbeat();
  },
  getUndoStack: function() {
   return state.undoStack;
  },
  getItemsCount: function() {
   return state.items.size;
  },
  connect: connect,
  disconnect: function() {
   state.socket && (state.socket.removeEventListener("open", onOpen), state.socket.removeEventListener("message", onMessage), 
   state.socket.removeEventListener("close", onClose), state.socket.removeEventListener("error", onError), 
   state.socket.close(), state.socket = null), updateConnection({
    state: "closed"
   }), state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush), clearTimeout(state.timeoutHandles.reconnect), 
   clearTimeout(state.timeoutHandles.pongTimeout), clearInterval(state.intervalHandles.heartbeat), 
   state.users = {}, notify({
    others: [ {
     type: "reset"
    } ]
   }), function() {
    for (var _key6 in state.listeners) state.listeners[_key6] = [];
   }();
  },
  subscribe: function(firstParam, listener, options) {
   if (firstParam instanceof LiveObject.AbstractCrdt) return function(crdt, innerCallback, options) {
    return genericSubscribe((function(updates) {
     for (var _step, relatedUpdates = [], _iterator = LiveObject._createForOfIteratorHelperLoose(updates); !(_step = _iterator()).done; ) {
      var update = _step.value;
      null != options && options.isDeep && LiveObject.isSameNodeOrChildOf(update.node, crdt) ? relatedUpdates.push(update) : update.node._id === crdt._id && innerCallback(update.node);
     }
     null != options && options.isDeep && relatedUpdates.length > 0 && innerCallback(relatedUpdates);
    }));
   }(firstParam, listener, options);
   if ("function" == typeof firstParam) return genericSubscribe(firstParam);
   if (!isValidRoomEventType(firstParam)) throw new Error('"' + firstParam + '" is not a valid event name');
   return state.listeners[firstParam].push(listener), function() {
    var callbacks = state.listeners[firstParam];
    LiveObject.remove(callbacks, listener);
   };
  },
  unsubscribe: function(event, callback) {
   if (console.warn("unsubscribe is depreacted and will be removed in a future version.\nuse the callback returned by subscribe instead.\nSee v0.13 release notes for more information.\n"), 
   !isValidRoomEventType(event)) throw new Error('"' + event + '" is not a valid event name');
   var callbacks = state.listeners[event];
   LiveObject.remove(callbacks, callback);
  },
  updatePresence: function(overrides, options) {
   var oldValues = {};
   for (var _key4 in null == state.buffer.presence && (state.buffer.presence = {}), 
   overrides) state.buffer.presence[_key4] = overrides[_key4], oldValues[_key4] = state.me[_key4];
   state.me = LiveObject._extends({}, state.me, overrides), state.isBatching ? (null != options && options.addToHistory && state.batch.reverseOps.push({
    type: "presence",
    data: oldValues
   }), state.batch.updates.presence = !0) : (tryFlushing(), null != options && options.addToHistory && addToUndoStack([ {
    type: "presence",
    data: oldValues
   } ]), notify({
    presence: !0
   }));
  },
  broadcastEvent: function(event, options) {
   void 0 === options && (options = {
    shouldQueueEventIfNotReady: !1
   }), null == state.socket && 0 == options.shouldQueueEventIfNotReady || (state.buffer.messages.push({
    type: LiveObject.ClientMsgCode.BROADCAST_EVENT,
    event: event
   }), tryFlushing());
  },
  batch: function(callback) {
   if (state.isBatching) throw new Error("batch should not be called during a batch");
   state.isBatching = !0;
   try {
    callback();
   } finally {
    state.isBatching = !1, state.batch.reverseOps.length > 0 && addToUndoStack(state.batch.reverseOps), 
    state.batch.ops.length > 0 && (state.redoStack = []), state.batch.ops.length > 0 && dispatch(state.batch.ops), 
    notify(state.batch.updates), state.batch = {
     ops: [],
     reverseOps: [],
     updates: {
      others: [],
      storageUpdates: new Map,
      presence: !1
     }
    }, tryFlushing();
   }
  },
  undo: function() {
   if (state.isBatching) throw new Error("undo is not allowed during a batch");
   var historyItem = state.undoStack.pop();
   if (null != historyItem) {
    state.isHistoryPaused = !1;
    var result = apply(historyItem, !0);
    notify(result.updates), state.redoStack.push(result.reverse);
    for (var _step13, _iterator13 = LiveObject._createForOfIteratorHelperLoose(historyItem); !(_step13 = _iterator13()).done; ) {
     var op = _step13.value;
     "presence" !== op.type && state.buffer.storageOperations.push(op);
    }
    tryFlushing();
   }
  },
  redo: function() {
   if (state.isBatching) throw new Error("redo is not allowed during a batch");
   var historyItem = state.redoStack.pop();
   if (null != historyItem) {
    state.isHistoryPaused = !1;
    var result = apply(historyItem, !0);
    notify(result.updates), state.undoStack.push(result.reverse);
    for (var _step14, _iterator14 = LiveObject._createForOfIteratorHelperLoose(historyItem); !(_step14 = _iterator14()).done; ) {
     var op = _step14.value;
     "presence" !== op.type && state.buffer.storageOperations.push(op);
    }
    tryFlushing();
   }
  },
  pauseHistory: function() {
   state.pausedHistory = [], state.isHistoryPaused = !0;
  },
  resumeHistory: function() {
   state.isHistoryPaused = !1, state.pausedHistory.length > 0 && addToUndoStack(state.pausedHistory), 
   state.pausedHistory = [];
  },
  getStorage: function() {
   return state.root ? new Promise((function(resolve) {
    return resolve({
     root: state.root
    });
   })) : (null == _getInitialStatePromise && (state.buffer.messages.push({
    type: LiveObject.ClientMsgCode.FETCH_STORAGE
   }), tryFlushing(), _getInitialStatePromise = new Promise((function(resolve) {
    return _getInitialStateResolver = resolve;
   }))), _getInitialStatePromise.then((function() {
    return {
     root: state.root
    };
   })));
  },
  selectors: {
   getConnectionState: function() {
    return state.connection.state;
   },
   getSelf: function() {
    return "open" === state.connection.state || "connecting" === state.connection.state ? {
     connectionId: state.connection.id,
     id: state.connection.userId,
     info: state.connection.userInfo,
     presence: getPresence()
    } : null;
   },
   getPresence: getPresence,
   getOthers: function() {
    return state.others;
   }
  }
 };
}

function createRoom(options, context) {
 var _options$initialPrese, _options$initialStora, initialPresence = null != (_options$initialPrese = options.initialPresence) ? _options$initialPrese : options.defaultPresence, initialStorage = null != (_options$initialStora = options.initialStorage) ? _options$initialStora : options.defaultStorageRoot, machine = makeStateMachine(function(initialPresence, initialStorage) {
  return {
   connection: {
    state: "closed"
   },
   token: null,
   lastConnectionId: null,
   socket: null,
   listeners: {
    event: [],
    others: [],
    "my-presence": [],
    error: [],
    connection: [],
    storage: []
   },
   numberOfRetry: 0,
   lastFlushTime: 0,
   timeoutHandles: {
    flush: null,
    reconnect: 0,
    pongTimeout: 0
   },
   buffer: {
    presence: null == initialPresence ? {} : initialPresence,
    messages: [],
    storageOperations: []
   },
   intervalHandles: {
    heartbeat: 0
   },
   me: null == initialPresence ? {} : initialPresence,
   users: {},
   others: makeOthers({}),
   defaultStorageRoot: initialStorage,
   idFactory: null,
   clock: 0,
   opClock: 0,
   items: new Map,
   root: void 0,
   undoStack: [],
   redoStack: [],
   isHistoryPaused: !1,
   pausedHistory: [],
   isBatching: !1,
   batch: {
    ops: [],
    updates: {
     storageUpdates: new Map,
     presence: !1,
     others: []
    },
    reverseOps: []
   },
   offlineOperations: new Map
  };
 }("function" == typeof initialPresence ? initialPresence(context.roomId) : initialPresence, "function" == typeof initialStorage ? initialStorage(context.roomId) : initialStorage), context), room = {
  id: context.roomId,
  getConnectionState: machine.selectors.getConnectionState,
  getSelf: machine.selectors.getSelf,
  subscribe: machine.subscribe,
  unsubscribe: machine.unsubscribe,
  getPresence: machine.selectors.getPresence,
  updatePresence: machine.updatePresence,
  getOthers: machine.selectors.getOthers,
  broadcastEvent: machine.broadcastEvent,
  getStorage: machine.getStorage,
  batch: machine.batch,
  history: {
   undo: machine.undo,
   redo: machine.redo,
   pause: machine.pauseHistory,
   resume: machine.resumeHistory
  },
  internalDevTools: {
   closeWebsocket: machine.simulateSocketClose,
   sendCloseEvent: machine.simulateSendCloseEvent
  }
 };
 return {
  connect: machine.connect,
  disconnect: machine.disconnect,
  onNavigatorOnline: machine.onNavigatorOnline,
  onVisibilityChange: machine.onVisibilityChange,
  room: room
 };
}

var LiveblocksError = function(_Error) {
 function LiveblocksError(message, code) {
  return _Error.call(this, message) || this;
 }
 return LiveObject._inheritsLoose(LiveblocksError, _Error), LiveblocksError;
}(LiveObject._wrapNativeSuper(Error));

function parseToken(token) {
 var tokenParts = token.split(".");
 if (3 !== tokenParts.length) throw new Error("Authentication error. Liveblocks could not parse the response of your authentication endpoint");
 var data = LiveObject.parseJson(atob(tokenParts[1]));
 if (void 0 !== data && LiveObject.isJsonObject(data) && "number" == typeof data.actor && (void 0 === data.id || "string" == typeof data.id)) return {
  actor: data.actor,
  id: data.id,
  info: data.info
 };
 throw new Error("Authentication error. Liveblocks could not parse the response of your authentication endpoint");
}

function fetchAuthEndpoint(fetch, endpoint, body) {
 return fetch(endpoint, {
  method: "POST",
  headers: {
   "Content-Type": "application/json"
  },
  body: JSON.stringify(body)
 }).then((function(res) {
  if (!res.ok) throw new AuthenticationError("Expected a status 200 but got " + res.status + ' when doing a POST request on "' + endpoint + '"');
  return res.json().catch((function(er) {
   throw new AuthenticationError('Expected a json when doing a POST request on "' + endpoint + '". ' + er);
  }));
 })).then((function(authResponse) {
  if ("string" != typeof authResponse.token) throw new AuthenticationError('Expected a json with a string token when doing a POST request on "' + endpoint + '", but got ' + JSON.stringify(authResponse));
  return authResponse;
 }));
}

var AuthenticationError = function(_Error2) {
 function AuthenticationError(message) {
  return _Error2.call(this, message) || this;
 }
 return LiveObject._inheritsLoose(AuthenticationError, _Error2), AuthenticationError;
}(LiveObject._wrapNativeSuper(Error));

function prepareAuthentication(clientOptions) {
 if ("string" == typeof clientOptions.publicApiKey) return {
  type: "public",
  publicApiKey: clientOptions.publicApiKey,
  url: clientOptions.publicAuthorizeEndpoint || "https://liveblocks.io/api/public/authorize"
 };
 if ("string" == typeof clientOptions.authEndpoint) return {
  type: "private",
  url: clientOptions.authEndpoint
 };
 if ("function" == typeof clientOptions.authEndpoint) return {
  type: "custom",
  callback: clientOptions.authEndpoint
 };
 throw new Error("Invalid Liveblocks client options. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient");
}

exports.LiveList = LiveObject.LiveList, exports.LiveMap = LiveObject.LiveMap, exports.LiveObject = LiveObject.LiveObject, 
exports.createClient = function(options) {
 var clientOptions = options, throttleDelay = function(options) {
  if (void 0 === options.throttle) return 100;
  if ("number" != typeof options.throttle || options.throttle < 80 || options.throttle > 1e3) throw new Error("throttle should be a number between 80 and 1000.");
  return options.throttle;
 }(options), rooms = new Map;
 return "undefined" != typeof window && window.addEventListener("online", (function() {
  for (var _step, _iterator = LiveObject._createForOfIteratorHelperLoose(rooms); !(_step = _iterator()).done; ) {
   _step.value[1].onNavigatorOnline();
  }
 })), "undefined" != typeof document && document.addEventListener("visibilitychange", (function() {
  for (var _step2, _iterator2 = LiveObject._createForOfIteratorHelperLoose(rooms); !(_step2 = _iterator2()).done; ) {
   _step2.value[1].onVisibilityChange(document.visibilityState);
  }
 })), {
  getRoom: function(roomId) {
   var internalRoom = rooms.get(roomId);
   return internalRoom ? internalRoom.room : null;
  },
  enter: function(roomId, options) {
   void 0 === options && (options = {});
   var internalRoom = rooms.get(roomId);
   return internalRoom || (LiveObject.deprecateIf(options.defaultPresence, "Argument `defaultPresence` will be removed in @liveblocks/client 0.18. Please use `initialPresence` instead. For more info, see https://bit.ly/3Niy5aP", "defaultPresence"), 
   LiveObject.deprecateIf(options.defaultStorageRoot, "Argument `defaultStorageRoot` will be removed in @liveblocks/client 0.18. Please use `initialStorage` instead. For more info, see https://bit.ly/3Niy5aP", "defaultStorageRoot"), 
   internalRoom = createRoom({
    initialPresence: options.initialPresence,
    initialStorage: options.initialStorage,
    defaultPresence: options.defaultPresence,
    defaultStorageRoot: options.defaultStorageRoot
   }, {
    roomId: roomId,
    throttleDelay: throttleDelay,
    WebSocketPolyfill: clientOptions.WebSocketPolyfill,
    fetchPolyfill: clientOptions.fetchPolyfill,
    liveblocksServer: clientOptions.liveblocksServer || "wss://liveblocks.net/v5",
    authentication: prepareAuthentication(clientOptions)
   }), rooms.set(roomId, internalRoom), options.DO_NOT_USE_withoutConnecting || internalRoom.connect()), 
   internalRoom.room;
  },
  leave: function(roomId) {
   var room = rooms.get(roomId);
   room && (room.disconnect(), rooms.delete(roomId));
  }
 };
};
