var ServerMsgCode, ClientMsgCode, CrdtType, OpCode, WebsocketCloseCodes;

!function(ServerMsgCode) {
 ServerMsgCode[ServerMsgCode.UPDATE_PRESENCE = 100] = "UPDATE_PRESENCE", ServerMsgCode[ServerMsgCode.USER_JOINED = 101] = "USER_JOINED", 
 ServerMsgCode[ServerMsgCode.USER_LEFT = 102] = "USER_LEFT", ServerMsgCode[ServerMsgCode.BROADCASTED_EVENT = 103] = "BROADCASTED_EVENT", 
 ServerMsgCode[ServerMsgCode.ROOM_STATE = 104] = "ROOM_STATE", ServerMsgCode[ServerMsgCode.INITIAL_STORAGE_STATE = 200] = "INITIAL_STORAGE_STATE", 
 ServerMsgCode[ServerMsgCode.UPDATE_STORAGE = 201] = "UPDATE_STORAGE";
}(ServerMsgCode || (ServerMsgCode = {})), function(ClientMsgCode) {
 ClientMsgCode[ClientMsgCode.UPDATE_PRESENCE = 100] = "UPDATE_PRESENCE", ClientMsgCode[ClientMsgCode.BROADCAST_EVENT = 103] = "BROADCAST_EVENT", 
 ClientMsgCode[ClientMsgCode.FETCH_STORAGE = 200] = "FETCH_STORAGE", ClientMsgCode[ClientMsgCode.UPDATE_STORAGE = 201] = "UPDATE_STORAGE";
}(ClientMsgCode || (ClientMsgCode = {})), function(CrdtType) {
 CrdtType[CrdtType.OBJECT = 0] = "OBJECT", CrdtType[CrdtType.LIST = 1] = "LIST", 
 CrdtType[CrdtType.MAP = 2] = "MAP", CrdtType[CrdtType.REGISTER = 3] = "REGISTER";
}(CrdtType || (CrdtType = {})), function(OpCode) {
 OpCode[OpCode.INIT = 0] = "INIT", OpCode[OpCode.SET_PARENT_KEY = 1] = "SET_PARENT_KEY", 
 OpCode[OpCode.CREATE_LIST = 2] = "CREATE_LIST", OpCode[OpCode.UPDATE_OBJECT = 3] = "UPDATE_OBJECT", 
 OpCode[OpCode.CREATE_OBJECT = 4] = "CREATE_OBJECT", OpCode[OpCode.DELETE_CRDT = 5] = "DELETE_CRDT", 
 OpCode[OpCode.DELETE_OBJECT_KEY = 6] = "DELETE_OBJECT_KEY", OpCode[OpCode.CREATE_MAP = 7] = "CREATE_MAP", 
 OpCode[OpCode.CREATE_REGISTER = 8] = "CREATE_REGISTER";
}(OpCode || (OpCode = {})), function(WebsocketCloseCodes) {
 WebsocketCloseCodes[WebsocketCloseCodes.CLOSE_ABNORMAL = 1006] = "CLOSE_ABNORMAL", 
 WebsocketCloseCodes[WebsocketCloseCodes.INVALID_MESSAGE_FORMAT = 4e3] = "INVALID_MESSAGE_FORMAT", 
 WebsocketCloseCodes[WebsocketCloseCodes.NOT_ALLOWED = 4001] = "NOT_ALLOWED", WebsocketCloseCodes[WebsocketCloseCodes.MAX_NUMBER_OF_MESSAGES_PER_SECONDS = 4002] = "MAX_NUMBER_OF_MESSAGES_PER_SECONDS", 
 WebsocketCloseCodes[WebsocketCloseCodes.MAX_NUMBER_OF_CONCURRENT_CONNECTIONS = 4003] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS", 
 WebsocketCloseCodes[WebsocketCloseCodes.MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP = 4004] = "MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP", 
 WebsocketCloseCodes[WebsocketCloseCodes.MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM = 4005] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM", 
 WebsocketCloseCodes[WebsocketCloseCodes.CLOSE_WITHOUT_RETRY = 4999] = "CLOSE_WITHOUT_RETRY";
}(WebsocketCloseCodes || (WebsocketCloseCodes = {}));

class AbstractCrdt {
 get _doc() {
  return this.__doc;
 }
 get roomId() {
  return this.__doc ? this.__doc.roomId : null;
 }
 get _id() {
  return this.__id;
 }
 get _parent() {
  return this.__parent;
 }
 get _parentKey() {
  return this.__parentKey;
 }
 _apply(op, _isLocal) {
  return op.type === OpCode.DELETE_CRDT && null != this._parent && null != this._parentKey ? this._parent._detachChild(this) : {
   modified: !1
  };
 }
 _setParentLink(parent, key) {
  if (null != this.__parent && this.__parent !== parent) throw new Error("Cannot attach parent if it already exist");
  this.__parentKey = key, this.__parent = parent;
 }
 _attach(id, doc) {
  if (this.__id || this.__doc) throw new Error("Cannot attach if CRDT is already attached");
  doc.addItem(id, this), this.__id = id, this.__doc = doc;
 }
 _detach() {
  this.__doc && this.__id && this.__doc.deleteItem(this.__id), this.__parent = void 0, 
  this.__doc = void 0;
 }
}

function parseJson(rawMessage) {
 try {
  return JSON.parse(rawMessage);
 } catch (e) {
  return;
 }
}

function isJsonArray(data) {
 return Array.isArray(data);
}

function isJsonObject(data) {
 return null !== data && "object" == typeof data && !isJsonArray(data);
}

class LiveRegister extends AbstractCrdt {
 constructor(data) {
  super(), this._data = data;
 }
 get data() {
  return this._data;
 }
 static _deserialize([id, item], _parentToChildren, doc) {
  if (item.type !== CrdtType.REGISTER) throw new Error(`Tried to deserialize a map but item type is "${item.type}"`);
  const register = new LiveRegister(item.data);
  return register._attach(id, doc), register;
 }
 _serialize(parentId, parentKey, doc, intent) {
  if (null == this._id || null == parentId || null == parentKey) throw new Error("Cannot serialize register if parentId or parentKey is undefined");
  return [ {
   type: OpCode.CREATE_REGISTER,
   opId: null == doc ? void 0 : doc.generateOpId(),
   id: this._id,
   intent: intent,
   parentId: parentId,
   parentKey: parentKey,
   data: this.data
  } ];
 }
 _toSerializedCrdt() {
  var _a;
  return {
   type: CrdtType.REGISTER,
   parentId: null === (_a = this._parent) || void 0 === _a ? void 0 : _a._id,
   parentKey: this._parentKey,
   data: this.data
  };
 }
 _attachChild(_op, _isLocal) {
  throw new Error("Method not implemented.");
 }
 _detachChild(_crdt) {
  throw new Error("Method not implemented.");
 }
 _apply(op, isLocal) {
  return super._apply(op, isLocal);
 }
}

function makePosition(before, after) {
 return null == before && null == after ? pos([ 33 ]) : null != before && null == after ? function(before) {
  const result = [], beforeCodes = posCodes(before);
  for (let i = 0; i < beforeCodes.length; i++) {
   const code = beforeCodes[i];
   if (126 !== code) {
    result.push(code + 1);
    break;
   }
   if (result.push(code), beforeCodes.length - 1 === i) {
    result.push(33);
    break;
   }
  }
  return pos(result);
 }(before) : null == before && null != after ? function(after) {
  const result = [], afterCodes = posCodes(after);
  for (let i = 0; i < afterCodes.length; i++) {
   const code = afterCodes[i];
   if (!(code <= 33)) {
    result.push(code - 1);
    break;
   }
   if (result.push(32), afterCodes.length - 1 === i) {
    result.push(126);
    break;
   }
  }
  return pos(result);
 }(after) : pos(makePositionFromCodes(posCodes(before), posCodes(after)));
}

function makePositionFromCodes(before, after) {
 let index = 0;
 const result = [];
 for (;;) {
  const beforeDigit = before[index] || 32, afterDigit = after[index] || 126;
  if (beforeDigit > afterDigit) throw new Error(`Impossible to generate position between ${before} and ${after}`);
  if (beforeDigit === afterDigit) {
   result.push(beforeDigit), index++;
   continue;
  }
  if (afterDigit - beforeDigit == 1) {
   result.push(beforeDigit), result.push(...makePositionFromCodes(before.slice(index + 1), []));
   break;
  }
  const mid = afterDigit + beforeDigit >> 1;
  result.push(mid);
  break;
 }
 return result;
}

function posCodes(str) {
 const codes = [];
 for (let i = 0; i < str.length; i++) codes.push(str.charCodeAt(i));
 return codes;
}

function pos(codes) {
 return String.fromCharCode(...codes);
}

function comparePosition(posA, posB) {
 const aCodes = posCodes(posA), bCodes = posCodes(posB), maxLength = Math.max(aCodes.length, bCodes.length);
 for (let i = 0; i < maxLength; i++) {
  const a = null == aCodes[i] ? 32 : aCodes[i], b = null == bCodes[i] ? 32 : bCodes[i];
  if (a !== b) return a - b;
 }
 throw new Error(`Impossible to compare similar position "${posA}" and "${posB}"`);
}

class LiveList extends AbstractCrdt {
 constructor(items = []) {
  let position;
  super(), this._items = [];
  for (let i = 0; i < items.length; i++) {
   const newPosition = makePosition(position), item = selfOrRegister(items[i]);
   this._items.push([ item, newPosition ]), position = newPosition;
  }
 }
 static _deserialize([id], parentToChildren, doc) {
  const list = new LiveList([]);
  list._attach(id, doc);
  const children = parentToChildren.get(id);
  if (null == children) return list;
  for (const entry of children) {
   const child = deserialize(entry, parentToChildren, doc);
   child._setParentLink(list, entry[1].parentKey), list._items.push([ child, entry[1].parentKey ]), 
   list._items.sort(((itemA, itemB) => comparePosition(itemA[1], itemB[1])));
  }
  return list;
 }
 _serialize(parentId, parentKey, doc, intent) {
  if (null == this._id) throw new Error("Cannot serialize item is not attached");
  if (null == parentId || null == parentKey) throw new Error("Cannot serialize list if parentId or parentKey is undefined");
  const ops = [], op = {
   id: this._id,
   opId: null == doc ? void 0 : doc.generateOpId(),
   intent: intent,
   type: OpCode.CREATE_LIST,
   parentId: parentId,
   parentKey: parentKey
  };
  ops.push(op);
  for (const [value, key] of this._items) ops.push(...value._serialize(this._id, key, doc));
  return ops;
 }
 _indexOfPosition(position) {
  return this._items.findIndex((item => item[1] === position));
 }
 _attach(id, doc) {
  super._attach(id, doc);
  for (const [item] of this._items) item._attach(doc.generateId(), doc);
 }
 _detach() {
  super._detach();
  for (const [value] of this._items) value._detach();
 }
 _attachChild(op, isLocal) {
  var _a;
  if (null == this._doc) throw new Error("Can't attach child if doc is not present");
  const {id: id, parentKey: parentKey, intent: intent} = op, key = parentKey, child = creationOpToLiveStructure(op);
  if (void 0 !== this._doc.getItem(id)) return {
   modified: !1
  };
  child._attach(id, this._doc), child._setParentLink(this, key);
  const index = this._items.findIndex((entry => entry[1] === key));
  let newKey = key;
  if (-1 !== index) {
   if ("set" === intent) {
    const existingItem = this._items[index][0];
    existingItem._detach();
    const storageUpdate = {
     node: this,
     type: "LiveList",
     updates: [ {
      index: index,
      type: "set",
      item: child instanceof LiveRegister ? child.data : child
     } ]
    };
    return this._items[index][0] = child, {
     modified: storageUpdate,
     reverse: existingItem._serialize(this._id, key, this._doc, "set")
    };
   }
   if (isLocal) {
    const before = this._items[index] ? this._items[index][1] : void 0, after = this._items[index + 1] ? this._items[index + 1][1] : void 0;
    newKey = makePosition(before, after), child._setParentLink(this, newKey);
   } else this._items[index][1] = makePosition(key, null === (_a = this._items[index + 1]) || void 0 === _a ? void 0 : _a[1]);
  }
  this._items.push([ child, newKey ]), this._items.sort(((itemA, itemB) => comparePosition(itemA[1], itemB[1])));
  const newIndex = this._items.findIndex((entry => entry[1] === newKey));
  return {
   reverse: [ {
    type: OpCode.DELETE_CRDT,
    id: id
   } ],
   modified: {
    node: this,
    type: "LiveList",
    updates: [ {
     index: newIndex,
     type: "insert",
     item: child instanceof LiveRegister ? child.data : child
    } ]
   }
  };
 }
 _detachChild(child) {
  if (child) {
   const reverse = child._serialize(this._id, child._parentKey, this._doc), indexToDelete = this._items.findIndex((item => item[0] === child));
   this._items.splice(indexToDelete, 1), child._detach();
   return {
    modified: {
     node: this,
     type: "LiveList",
     updates: [ {
      index: indexToDelete,
      type: "delete"
     } ]
    },
    reverse: reverse
   };
  }
  return {
   modified: !1
  };
 }
 _setChildKey(key, child, previousKey) {
  var _a;
  child._setParentLink(this, key);
  const previousIndex = this._items.findIndex((entry => entry[0]._id === child._id)), index = this._items.findIndex((entry => entry[1] === key));
  -1 !== index && (this._items[index][1] = makePosition(key, null === (_a = this._items[index + 1]) || void 0 === _a ? void 0 : _a[1]));
  const item = this._items.find((item => item[0] === child));
  item && (item[1] = key), this._items.sort(((itemA, itemB) => comparePosition(itemA[1], itemB[1])));
  const newIndex = this._items.findIndex((entry => entry[0]._id === child._id));
  return {
   modified: {
    node: this,
    type: "LiveList",
    updates: newIndex === previousIndex ? [] : [ {
     index: newIndex,
     item: child instanceof LiveRegister ? child.data : child,
     previousIndex: previousIndex,
     type: "move"
    } ]
   },
   reverse: [ {
    type: OpCode.SET_PARENT_KEY,
    id: null == item ? void 0 : item[0]._id,
    parentKey: previousKey
   } ]
  };
 }
 _apply(op, isLocal) {
  return super._apply(op, isLocal);
 }
 _toSerializedCrdt() {
  var _a;
  return {
   type: CrdtType.LIST,
   parentId: null === (_a = this._parent) || void 0 === _a ? void 0 : _a._id,
   parentKey: this._parentKey
  };
 }
 get length() {
  return this._items.length;
 }
 push(element) {
  return this.insert(element, this.length);
 }
 insert(element, index) {
  if (index < 0 || index > this._items.length) throw new Error(`Cannot insert list item at index "${index}". index should be between 0 and ${this._items.length}`);
  const position = makePosition(this._items[index - 1] ? this._items[index - 1][1] : void 0, this._items[index] ? this._items[index][1] : void 0), value = selfOrRegister(element);
  value._setParentLink(this, position), this._items.push([ value, position ]), this._items.sort(((itemA, itemB) => comparePosition(itemA[1], itemB[1])));
  const newIndex = this._items.findIndex((entry => entry[1] === position));
  if (this._doc && this._id) {
   const id = this._doc.generateId();
   value._attach(id, this._doc);
   const storageUpdates = new Map;
   storageUpdates.set(this._id, {
    node: this,
    type: "LiveList",
    updates: [ {
     index: newIndex,
     item: value instanceof LiveRegister ? value.data : value,
     type: "insert"
    } ]
   }), this._doc.dispatch(value._serialize(this._id, position, this._doc), [ {
    type: OpCode.DELETE_CRDT,
    id: id
   } ], storageUpdates);
  }
 }
 move(index, targetIndex) {
  if (targetIndex < 0) throw new Error("targetIndex cannot be less than 0");
  if (targetIndex >= this._items.length) throw new Error("targetIndex cannot be greater or equal than the list length");
  if (index < 0) throw new Error("index cannot be less than 0");
  if (index >= this._items.length) throw new Error("index cannot be greater or equal than the list length");
  let beforePosition = null, afterPosition = null;
  index < targetIndex ? (afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1][1], 
  beforePosition = this._items[targetIndex][1]) : (afterPosition = this._items[targetIndex][1], 
  beforePosition = 0 === targetIndex ? void 0 : this._items[targetIndex - 1][1]);
  const position = makePosition(beforePosition, afterPosition), item = this._items[index], previousPosition = item[1];
  item[1] = position, item[0]._setParentLink(this, position), this._items.sort(((itemA, itemB) => comparePosition(itemA[1], itemB[1])));
  const newIndex = this._items.findIndex((entry => entry[1] === position));
  if (this._doc && this._id) {
   const storageUpdates = new Map;
   storageUpdates.set(this._id, {
    node: this,
    type: "LiveList",
    updates: [ {
     index: newIndex,
     previousIndex: index,
     item: item[0],
     type: "move"
    } ]
   }), this._doc.dispatch([ {
    type: OpCode.SET_PARENT_KEY,
    id: item[0]._id,
    opId: this._doc.generateOpId(),
    parentKey: position
   } ], [ {
    type: OpCode.SET_PARENT_KEY,
    id: item[0]._id,
    parentKey: previousPosition
   } ], storageUpdates);
  }
 }
 delete(index) {
  if (index < 0 || index >= this._items.length) throw new Error(`Cannot delete list item at index "${index}". index should be between 0 and ${this._items.length - 1}`);
  const item = this._items[index];
  if (item[0]._detach(), this._items.splice(index, 1), this._doc) {
   const childRecordId = item[0]._id;
   if (childRecordId) {
    const storageUpdates = new Map;
    storageUpdates.set(this._id, {
     node: this,
     type: "LiveList",
     updates: [ {
      index: index,
      type: "delete"
     } ]
    }), this._doc.dispatch([ {
     id: childRecordId,
     opId: this._doc.generateOpId(),
     type: OpCode.DELETE_CRDT
    } ], item[0]._serialize(this._id, item[1]), storageUpdates);
   }
  }
 }
 clear() {
  if (this._doc) {
   const ops = [], reverseOps = [], updateDelta = [];
   let i = 0;
   for (const item of this._items) {
    item[0]._detach();
    const childId = item[0]._id;
    childId && (ops.push({
     id: childId,
     type: OpCode.DELETE_CRDT
    }), reverseOps.push(...item[0]._serialize(this._id, item[1])), updateDelta.push({
     index: i,
     type: "delete"
    })), i++;
   }
   this._items = [];
   const storageUpdates = new Map;
   storageUpdates.set(this._id, {
    node: this,
    type: "LiveList",
    updates: updateDelta
   }), this._doc.dispatch(ops, reverseOps, storageUpdates);
  } else {
   for (const item of this._items) item[0]._detach();
   this._items = [];
  }
 }
 set(index, item) {
  if (index < 0 || index >= this._items.length) throw new Error(`Cannot set list item at index "${index}". index should be between 0 and ${this._items.length - 1}`);
  const [existingItem, position] = this._items[index];
  existingItem._detach();
  const value = selfOrRegister(item);
  if (value._setParentLink(this, position), this._items[index][0] = value, this._doc && this._id) {
   const id = this._doc.generateId();
   value._attach(id, this._doc);
   const storageUpdates = new Map;
   storageUpdates.set(this._id, {
    node: this,
    type: "LiveList",
    updates: [ {
     index: index,
     item: value instanceof LiveRegister ? value.data : value,
     type: "set"
    } ]
   }), this._doc.dispatch(value._serialize(this._id, position, this._doc, "set"), existingItem._serialize(this._id, position, void 0, "set"), storageUpdates);
  }
 }
 toArray() {
  return this._items.map((entry => selfOrRegisterValue(entry[0])));
 }
 every(predicate) {
  return this.toArray().every(predicate);
 }
 filter(predicate) {
  return this.toArray().filter(predicate);
 }
 find(predicate) {
  return this.toArray().find(predicate);
 }
 findIndex(predicate) {
  return this.toArray().findIndex(predicate);
 }
 forEach(callbackfn) {
  return this.toArray().forEach(callbackfn);
 }
 get(index) {
  if (!(index < 0 || index >= this._items.length)) return selfOrRegisterValue(this._items[index][0]);
 }
 indexOf(searchElement, fromIndex) {
  return this.toArray().indexOf(searchElement, fromIndex);
 }
 lastIndexOf(searchElement, fromIndex) {
  return this.toArray().lastIndexOf(searchElement, fromIndex);
 }
 map(callback) {
  return this._items.map(((entry, i) => callback(selfOrRegisterValue(entry[0]), i)));
 }
 some(predicate) {
  return this.toArray().some(predicate);
 }
 [Symbol.iterator]() {
  return new LiveListIterator(this._items);
 }
}

class LiveListIterator {
 constructor(items) {
  this._innerIterator = items[Symbol.iterator]();
 }
 [Symbol.iterator]() {
  return this;
 }
 next() {
  const result = this._innerIterator.next();
  return result.done ? {
   done: !0,
   value: void 0
  } : {
   value: selfOrRegisterValue(result.value[0])
  };
 }
}

const _emittedDeprecationWarnings = new Set;

function deprecate(message, key = message) {
 "production" !== process.env.NODE_ENV && (_emittedDeprecationWarnings.has(key) || (_emittedDeprecationWarnings.add(key), 
 console.error(`DEPRECATION WARNING: ${message}`)));
}

function deprecateIf(condition, message, key = message) {
 "production" !== process.env.NODE_ENV && condition && deprecate(message, key);
}

function throwUsageError(message) {
 if ("production" !== process.env.NODE_ENV) {
  const usageError = new Error(message);
  throw usageError.name = "Usage error", usageError;
 }
}

function errorIf(condition, message) {
 "production" !== process.env.NODE_ENV && condition && throwUsageError(message);
}

class LiveMap extends AbstractCrdt {
 constructor(entries) {
  if (super(), deprecateIf(null === entries, "Support for calling `new LiveMap(null)` will be removed in @liveblocks/client 0.18. Please call as `new LiveMap()`, or `new LiveMap([])`."), 
  entries) {
   const mappedEntries = [];
   for (const entry of entries) {
    const value = selfOrRegister(entry[1]);
    value._setParentLink(this, entry[0]), mappedEntries.push([ entry[0], value ]);
   }
   this._map = new Map(mappedEntries);
  } else this._map = new Map;
 }
 _serialize(parentId, parentKey, doc, intent) {
  if (null == this._id) throw new Error("Cannot serialize item is not attached");
  if (null == parentId || null == parentKey) throw new Error("Cannot serialize map if parentId or parentKey is undefined");
  const ops = [], op = {
   id: this._id,
   opId: null == doc ? void 0 : doc.generateOpId(),
   type: OpCode.CREATE_MAP,
   intent: intent,
   parentId: parentId,
   parentKey: parentKey
  };
  ops.push(op);
  for (const [key, value] of this._map) ops.push(...value._serialize(this._id, key, doc));
  return ops;
 }
 static _deserialize([id, item], parentToChildren, doc) {
  if (item.type !== CrdtType.MAP) throw new Error(`Tried to deserialize a map but item type is "${item.type}"`);
  const map = new LiveMap;
  map._attach(id, doc);
  const children = parentToChildren.get(id);
  if (null == children) return map;
  for (const entry of children) {
   const crdt = entry[1];
   if (null == crdt.parentKey) throw new Error("Tried to deserialize a crdt but it does not have a parentKey and is not the root");
   const child = deserialize(entry, parentToChildren, doc);
   child._setParentLink(map, crdt.parentKey), map._map.set(crdt.parentKey, child);
  }
  return map;
 }
 _attach(id, doc) {
  super._attach(id, doc);
  for (const [_key, value] of this._map) isCrdt(value) && value._attach(doc.generateId(), doc);
 }
 _attachChild(op, _isLocal) {
  if (null == this._doc) throw new Error("Can't attach child if doc is not present");
  const {id: id, parentKey: parentKey} = op, key = parentKey, child = creationOpToLiveStructure(op);
  if (void 0 !== this._doc.getItem(id)) return {
   modified: !1
  };
  const previousValue = this._map.get(key);
  let reverse;
  return previousValue ? (reverse = previousValue._serialize(this._id, key), previousValue._detach()) : reverse = [ {
   type: OpCode.DELETE_CRDT,
   id: id
  } ], child._setParentLink(this, key), child._attach(id, this._doc), this._map.set(key, child), 
  {
   modified: {
    node: this,
    type: "LiveMap",
    updates: {
     [key]: {
      type: "update"
     }
    }
   },
   reverse: reverse
  };
 }
 _detach() {
  super._detach();
  for (const item of this._map.values()) item._detach();
 }
 _detachChild(child) {
  const reverse = child._serialize(this._id, child._parentKey, this._doc);
  for (const [key, value] of this._map) value === child && this._map.delete(key);
  child._detach();
  return {
   modified: {
    node: this,
    type: "LiveMap",
    updates: {
     [child._parentKey]: {
      type: "delete"
     }
    }
   },
   reverse: reverse
  };
 }
 _toSerializedCrdt() {
  var _a;
  return {
   type: CrdtType.MAP,
   parentId: null === (_a = this._parent) || void 0 === _a ? void 0 : _a._id,
   parentKey: this._parentKey
  };
 }
 get(key) {
  const value = this._map.get(key);
  if (null != value) return selfOrRegisterValue(value);
 }
 set(key, value) {
  const oldValue = this._map.get(key);
  oldValue && oldValue._detach();
  const item = selfOrRegister(value);
  if (item._setParentLink(this, key), this._map.set(key, item), this._doc && this._id) {
   const id = this._doc.generateId();
   item._attach(id, this._doc);
   const storageUpdates = new Map;
   storageUpdates.set(this._id, {
    node: this,
    type: "LiveMap",
    updates: {
     [key]: {
      type: "update"
     }
    }
   }), this._doc.dispatch(item._serialize(this._id, key, this._doc), oldValue ? oldValue._serialize(this._id, key) : [ {
    type: OpCode.DELETE_CRDT,
    id: id
   } ], storageUpdates);
  }
 }
 get size() {
  return this._map.size;
 }
 has(key) {
  return this._map.has(key);
 }
 delete(key) {
  const item = this._map.get(key);
  if (null == item) return !1;
  if (item._detach(), this._map.delete(key), this._doc && item._id) {
   const storageUpdates = new Map;
   storageUpdates.set(this._id, {
    node: this,
    type: "LiveMap",
    updates: {
     [key]: {
      type: "delete"
     }
    }
   }), this._doc.dispatch([ {
    type: OpCode.DELETE_CRDT,
    id: item._id,
    opId: this._doc.generateOpId()
   } ], item._serialize(this._id, key), storageUpdates);
  }
  return !0;
 }
 entries() {
  const innerIterator = this._map.entries();
  return {
   [Symbol.iterator]: function() {
    return this;
   },
   next() {
    const iteratorValue = innerIterator.next();
    if (iteratorValue.done) return {
     done: !0,
     value: void 0
    };
    return {
     value: [ iteratorValue.value[0], selfOrRegisterValue(iteratorValue.value[1]) ]
    };
   }
  };
 }
 [Symbol.iterator]() {
  return this.entries();
 }
 keys() {
  return this._map.keys();
 }
 values() {
  const innerIterator = this._map.values();
  return {
   [Symbol.iterator]: function() {
    return this;
   },
   next() {
    const iteratorValue = innerIterator.next();
    return iteratorValue.done ? {
     done: !0,
     value: void 0
    } : {
     value: selfOrRegisterValue(iteratorValue.value)
    };
   }
  };
 }
 forEach(callback) {
  for (const entry of this) callback(entry[1], entry[0], this);
 }
}

function remove(array, item) {
 for (let i = 0; i < array.length; i++) if (array[i] === item) {
  array.splice(i, 1);
  break;
 }
}

function compact(items) {
 return items.filter((item => null != item));
}

function creationOpToLiveStructure(op) {
 switch (op.type) {
 case OpCode.CREATE_REGISTER:
  return new LiveRegister(op.data);

 case OpCode.CREATE_OBJECT:
  return new LiveObject(op.data);

 case OpCode.CREATE_MAP:
  return new LiveMap;

 case OpCode.CREATE_LIST:
  return new LiveList;
 }
}

function isSameNodeOrChildOf(node, parent) {
 return node === parent || !!node._parent && isSameNodeOrChildOf(node._parent, parent);
}

function deserialize(entry, parentToChildren, doc) {
 switch (entry[1].type) {
 case CrdtType.OBJECT:
  return LiveObject._deserialize(entry, parentToChildren, doc);

 case CrdtType.LIST:
  return LiveList._deserialize(entry, parentToChildren, doc);

 case CrdtType.MAP:
  return LiveMap._deserialize(entry, parentToChildren, doc);

 case CrdtType.REGISTER:
  return LiveRegister._deserialize(entry, parentToChildren, doc);

 default:
  throw new Error("Unexpected CRDT type");
 }
}

function isCrdt(obj) {
 return obj instanceof LiveObject || obj instanceof LiveMap || obj instanceof LiveList || obj instanceof LiveRegister;
}

function selfOrRegisterValue(obj) {
 return obj instanceof LiveRegister ? obj.data : obj;
}

function selfOrRegister(obj) {
 if (obj instanceof LiveObject || obj instanceof LiveMap || obj instanceof LiveList) return obj;
 if (obj instanceof LiveRegister) throw new Error("Internal error. LiveRegister should not be created from selfOrRegister");
 return new LiveRegister(obj);
}

function getTreesDiffOperations(currentItems, newItems) {
 const ops = [];
 return currentItems.forEach(((_, id) => {
  newItems.get(id) || ops.push({
   type: OpCode.DELETE_CRDT,
   id: id
  });
 })), newItems.forEach(((crdt, id) => {
  const currentCrdt = currentItems.get(id);
  if (currentCrdt) crdt.type === CrdtType.OBJECT && JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data) && ops.push({
   type: OpCode.UPDATE_OBJECT,
   id: id,
   data: crdt.data
  }), crdt.parentKey !== currentCrdt.parentKey && ops.push({
   type: OpCode.SET_PARENT_KEY,
   id: id,
   parentKey: crdt.parentKey
  }); else switch (crdt.type) {
  case CrdtType.REGISTER:
   ops.push({
    type: OpCode.CREATE_REGISTER,
    id: id,
    parentId: crdt.parentId,
    parentKey: crdt.parentKey,
    data: crdt.data
   });
   break;

  case CrdtType.LIST:
   ops.push({
    type: OpCode.CREATE_LIST,
    id: id,
    parentId: crdt.parentId,
    parentKey: crdt.parentKey
   });
   break;

  case CrdtType.OBJECT:
   ops.push({
    type: OpCode.CREATE_OBJECT,
    id: id,
    parentId: crdt.parentId,
    parentKey: crdt.parentKey,
    data: crdt.data
   });
   break;

  case CrdtType.MAP:
   ops.push({
    type: OpCode.CREATE_MAP,
    id: id,
    parentId: crdt.parentId,
    parentKey: crdt.parentKey
   });
  }
 })), ops;
}

function mergeStorageUpdates(first, second) {
 return first ? "LiveObject" === first.type && "LiveObject" === second.type ? function(first, second) {
  const updates = first.updates;
  for (const [key, value] of entries(second.updates)) updates[key] = value;
  return Object.assign(Object.assign({}, second), {
   updates: updates
  });
 }(first, second) : "LiveMap" === first.type && "LiveMap" === second.type ? function(first, second) {
  const updates = first.updates;
  for (const [key, value] of entries(second.updates)) updates[key] = value;
  return Object.assign(Object.assign({}, second), {
   updates: updates
  });
 }(first, second) : "LiveList" === first.type && "LiveList" === second.type ? function(first, second) {
  const updates = first.updates;
  return Object.assign(Object.assign({}, second), {
   updates: updates.concat(second.updates)
  });
 }(first, second) : second : second;
}

function isPlain(value) {
 const type = typeof value;
 return "undefined" === type || null === value || "string" === type || "boolean" === type || "number" === type || Array.isArray(value) || function(value) {
  if ("object" != typeof value || null === value) return !1;
  const proto = Object.getPrototypeOf(value);
  if (null === proto) return !0;
  let baseProto = proto;
  for (;null !== Object.getPrototypeOf(baseProto); ) baseProto = Object.getPrototypeOf(baseProto);
  return proto === baseProto;
 }(value);
}

function findNonSerializableValue(value, path = "") {
 if (!isPlain) return {
  path: path || "root",
  value: value
 };
 if ("object" != typeof value || null === value) return !1;
 for (const [key, nestedValue] of Object.entries(value)) {
  const nestedPath = path ? path + "." + key : key;
  if (!isPlain(nestedValue)) return {
   path: nestedPath,
   value: nestedValue
  };
  if ("object" == typeof nestedValue) {
   const nonSerializableNestedValue = findNonSerializableValue(nestedValue, nestedPath);
   if (nonSerializableNestedValue) return nonSerializableNestedValue;
  }
 }
 return !1;
}

function isTokenValid(token) {
 const tokenParts = token.split(".");
 if (3 !== tokenParts.length) return !1;
 const data = parseJson(atob(tokenParts[1]));
 if (void 0 === data || !isJsonObject(data) || "number" != typeof data.exp) return !1;
 return !(Date.now() / 1e3 > data.exp - 300);
}

function entries(obj) {
 return Object.entries(obj);
}

class LiveObject extends AbstractCrdt {
 constructor(obj = {}) {
  super(), this._propToLastUpdate = new Map;
  for (const key in obj) {
   const value = obj[key];
   value instanceof AbstractCrdt && value._setParentLink(this, key);
  }
  this._map = new Map(Object.entries(obj));
 }
 _serialize(parentId, parentKey, doc, intent) {
  if (null == this._id) throw new Error("Cannot serialize item is not attached");
  const ops = [], op = {
   id: this._id,
   opId: null == doc ? void 0 : doc.generateOpId(),
   intent: intent,
   type: OpCode.CREATE_OBJECT,
   parentId: parentId,
   parentKey: parentKey,
   data: {}
  };
  ops.push(op);
  for (const [key, value] of this._map) value instanceof AbstractCrdt ? ops.push(...value._serialize(this._id, key, doc)) : op.data[key] = value;
  return ops;
 }
 static _deserialize([id, item], parentToChildren, doc) {
  if (item.type !== CrdtType.OBJECT) throw new Error(`Tried to deserialize a record but item type is "${item.type}"`);
  const liveObj = new LiveObject(item.data);
  return liveObj._attach(id, doc), this._deserializeChildren(liveObj, parentToChildren, doc);
 }
 static _deserializeChildren(liveObj, parentToChildren, doc) {
  const children = parentToChildren.get(liveObj._id);
  if (null == children) return liveObj;
  for (const entry of children) {
   const crdt = entry[1];
   if (null == crdt.parentKey) throw new Error("Tried to deserialize a crdt but it does not have a parentKey and is not the root");
   const child = deserialize(entry, parentToChildren, doc);
   child._setParentLink(liveObj, crdt.parentKey), liveObj._map.set(crdt.parentKey, child);
  }
  return liveObj;
 }
 _attach(id, doc) {
  super._attach(id, doc);
  for (const [_key, value] of this._map) value instanceof AbstractCrdt && value._attach(doc.generateId(), doc);
 }
 _attachChild(op, isLocal) {
  if (null == this._doc) throw new Error("Can't attach child if doc is not present");
  const {id: id, parentKey: parentKey, opId: opId} = op, key = parentKey, child = creationOpToLiveStructure(op);
  if (void 0 !== this._doc.getItem(id)) return this._propToLastUpdate.get(key) === opId && this._propToLastUpdate.delete(key), 
  {
   modified: !1
  };
  if (isLocal) this._propToLastUpdate.set(key, opId); else if (void 0 !== this._propToLastUpdate.get(key)) return this._propToLastUpdate.get(key) === opId ? (this._propToLastUpdate.delete(key), 
  {
   modified: !1
  }) : {
   modified: !1
  };
  const previousValue = this._map.get(key);
  let reverse;
  return isCrdt(previousValue) ? (reverse = previousValue._serialize(this._id, key), 
  previousValue._detach()) : reverse = void 0 === previousValue ? [ {
   type: OpCode.DELETE_OBJECT_KEY,
   id: this._id,
   key: key
  } ] : [ {
   type: OpCode.UPDATE_OBJECT,
   id: this._id,
   data: {
    [key]: previousValue
   }
  } ], this._map.set(key, child), child._setParentLink(this, key), child._attach(id, this._doc), 
  {
   reverse: reverse,
   modified: {
    node: this,
    type: "LiveObject",
    updates: {
     [key]: {
      type: "update"
     }
    }
   }
  };
 }
 _detachChild(child) {
  if (child) {
   const reverse = child._serialize(this._id, child._parentKey, this._doc);
   for (const [key, value] of this._map) value === child && this._map.delete(key);
   child._detach();
   return {
    modified: {
     node: this,
     type: "LiveObject",
     updates: {
      [child._parentKey]: {
       type: "delete"
      }
     }
    },
    reverse: reverse
   };
  }
  return {
   modified: !1
  };
 }
 _detachChildren() {
  for (const [key, value] of this._map) this._map.delete(key), value._detach();
 }
 _detach() {
  super._detach();
  for (const value of this._map.values()) isCrdt(value) && value._detach();
 }
 _apply(op, isLocal) {
  return op.type === OpCode.UPDATE_OBJECT ? this._applyUpdate(op, isLocal) : op.type === OpCode.DELETE_OBJECT_KEY ? this._applyDeleteObjectKey(op) : super._apply(op, isLocal);
 }
 _toSerializedCrdt() {
  var _a;
  const data = {};
  for (const [key, value] of this._map) value instanceof AbstractCrdt == !1 && (data[key] = value);
  return {
   type: CrdtType.OBJECT,
   parentId: null === (_a = this._parent) || void 0 === _a ? void 0 : _a._id,
   parentKey: this._parentKey,
   data: data
  };
 }
 _applyUpdate(op, isLocal) {
  let isModified = !1;
  const reverse = [], reverseUpdate = {
   type: OpCode.UPDATE_OBJECT,
   id: this._id,
   data: {}
  };
  reverse.push(reverseUpdate);
  for (const key in op.data) {
   const oldValue = this._map.get(key);
   oldValue instanceof AbstractCrdt ? (reverse.push(...oldValue._serialize(this._id, key)), 
   oldValue._detach()) : void 0 !== oldValue ? reverseUpdate.data[key] = oldValue : void 0 === oldValue && reverse.push({
    type: OpCode.DELETE_OBJECT_KEY,
    id: this._id,
    key: key
   });
  }
  const updateDelta = {};
  for (const key in op.data) {
   if (isLocal) this._propToLastUpdate.set(key, op.opId); else {
    if (null != this._propToLastUpdate.get(key)) {
     if (this._propToLastUpdate.get(key) === op.opId) {
      this._propToLastUpdate.delete(key);
      continue;
     }
     continue;
    }
    isModified = !0;
   }
   const oldValue = this._map.get(key);
   isCrdt(oldValue) && oldValue._detach(), isModified = !0, updateDelta[key] = {
    type: "update"
   }, this._map.set(key, op.data[key]);
  }
  return 0 !== Object.keys(reverseUpdate.data).length && reverse.unshift(reverseUpdate), 
  isModified ? {
   modified: {
    node: this,
    type: "LiveObject",
    updates: updateDelta
   },
   reverse: reverse
  } : {
   modified: !1
  };
 }
 _applyDeleteObjectKey(op) {
  const key = op.key;
  if (!1 === this._map.has(key)) return {
   modified: !1
  };
  if (void 0 !== this._propToLastUpdate.get(key)) return {
   modified: !1
  };
  const oldValue = this._map.get(key);
  let reverse = [];
  return isCrdt(oldValue) ? (reverse = oldValue._serialize(this._id, op.key), oldValue._detach()) : void 0 !== oldValue && (reverse = [ {
   type: OpCode.UPDATE_OBJECT,
   id: this._id,
   data: {
    [key]: oldValue
   }
  } ]), this._map.delete(key), {
   modified: {
    node: this,
    type: "LiveObject",
    updates: {
     [op.key]: {
      type: "delete"
     }
    }
   },
   reverse: reverse
  };
 }
 toObject() {
  return function(iterable) {
   const obj = {};
   for (const [key, val] of iterable) obj[key] = val;
   return obj;
  }(this._map);
 }
 set(key, value) {
  this.update({
   [key]: value
  });
 }
 get(key) {
  return this._map.get(key);
 }
 delete(key) {
  const keyAsString = key, oldValue = this._map.get(keyAsString);
  if (void 0 === oldValue) return;
  if (null == this._doc || null == this._id) return oldValue instanceof AbstractCrdt && oldValue._detach(), 
  void this._map.delete(keyAsString);
  let reverse;
  oldValue instanceof AbstractCrdt ? (oldValue._detach(), reverse = oldValue._serialize(this._id, keyAsString)) : reverse = [ {
   type: OpCode.UPDATE_OBJECT,
   data: {
    [keyAsString]: oldValue
   },
   id: this._id
  } ], this._map.delete(keyAsString);
  const storageUpdates = new Map;
  storageUpdates.set(this._id, {
   node: this,
   type: "LiveObject",
   updates: {
    [key]: {
     type: "delete"
    }
   }
  }), this._doc.dispatch([ {
   type: OpCode.DELETE_OBJECT_KEY,
   key: keyAsString,
   id: this._id,
   opId: this._doc.generateOpId()
  } ], reverse, storageUpdates);
 }
 update(overrides) {
  if (null == this._doc || null == this._id) {
   for (const key in overrides) {
    const oldValue = this._map.get(key);
    oldValue instanceof AbstractCrdt && oldValue._detach();
    const newValue = overrides[key];
    newValue instanceof AbstractCrdt && newValue._setParentLink(this, key), this._map.set(key, newValue);
   }
   return;
  }
  const ops = [], reverseOps = [], opId = this._doc.generateOpId(), updatedProps = {}, reverseUpdateOp = {
   id: this._id,
   type: OpCode.UPDATE_OBJECT,
   data: {}
  }, updateDelta = {};
  for (const key in overrides) {
   const oldValue = this._map.get(key);
   oldValue instanceof AbstractCrdt ? (reverseOps.push(...oldValue._serialize(this._id, key)), 
   oldValue._detach()) : void 0 === oldValue ? reverseOps.push({
    type: OpCode.DELETE_OBJECT_KEY,
    id: this._id,
    key: key
   }) : reverseUpdateOp.data[key] = oldValue;
   const newValue = overrides[key];
   if (newValue instanceof AbstractCrdt) {
    newValue._setParentLink(this, key), newValue._attach(this._doc.generateId(), this._doc);
    const newAttachChildOps = newValue._serialize(this._id, key, this._doc), createCrdtOp = newAttachChildOps.find((op => op.parentId === this._id));
    createCrdtOp && this._propToLastUpdate.set(key, createCrdtOp.opId), ops.push(...newAttachChildOps);
   } else updatedProps[key] = newValue, this._propToLastUpdate.set(key, opId);
   this._map.set(key, newValue), updateDelta[key] = {
    type: "update"
   };
  }
  0 !== Object.keys(reverseUpdateOp.data).length && reverseOps.unshift(reverseUpdateOp), 
  0 !== Object.keys(updatedProps).length && ops.unshift({
   opId: opId,
   id: this._id,
   type: OpCode.UPDATE_OBJECT,
   data: updatedProps
  });
  const storageUpdates = new Map;
  storageUpdates.set(this._id, {
   node: this,
   type: "LiveObject",
   updates: updateDelta
  }), this._doc.dispatch(ops, reverseOps, storageUpdates);
 }
}

export { AbstractCrdt as A, ClientMsgCode as C, LiveObject as L, OpCode as O, ServerMsgCode as S, WebsocketCloseCodes as W, isSameNodeOrChildOf as a, LiveList as b, isJsonArray as c, compact as d, isJsonObject as e, deprecateIf as f, getTreesDiffOperations as g, LiveMap as h, isTokenValid as i, LiveRegister as j, findNonSerializableValue as k, deprecate as l, mergeStorageUpdates as m, errorIf as n, CrdtType as o, parseJson as p, comparePosition as q, remove as r, makePosition as s, throwUsageError as t };
